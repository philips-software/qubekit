// This file is auto-generated by @hey-api/openapi-ts

export type UserCreateRestRequest = {
  /**
   * User email
   */
  email?: string;
  /**
   * Specify if the user should be authenticated from SonarQube server or from an external authentication system. Password should not be set when local is set to false.
   */
  local?: boolean;
  /**
   * User login
   */
  login: string;
  /**
   * User name
   */
  name: string;
  /**
   * List of SCM accounts.
   */
  scmAccounts?: Array<string>;
};

export type UserRestResponseForAdmins = {
  readonly id?: string;
  login?: string;
  name?: string;
  email?: string;
  readonly active?: boolean;
  readonly local?: boolean;
  readonly managed?: boolean;
  externalLogin?: string;
  externalProvider?: string;
  externalId?: string;
  avatar?: string;
  readonly sonarQubeLastConnectionDate?: string;
  readonly sonarLintLastConnectionDate?: string;
  scmAccounts?: Array<string>;
};

export type EmailConfigurationCreateRestRequest = {
  /**
   * URL of your SMTP server
   */
  host: string;
  /**
   * Port of your SMTP server (usually 25, 587 or 465)
   */
  port: string;
  /**
   * Security protocol used to connect to your SMTP server (SSLTLS is recommended)
   */
  securityProtocol: 'NONE' | 'SSLTLS' | 'STARTTLS';
  /**
   * Address emails will come from
   */
  fromAddress: string;
  /**
   * Name emails will come from (usually "SonarQube")
   */
  fromName: string;
  /**
   * Prefix added to email so they can be easily recognized (usually "[SonarQube]")
   */
  subjectPrefix: string;
  /**
   * Authentication method used to connect to the SMTP server. OAuth is only supported for Microsoft Exchange
   */
  authMethod: 'BASIC' | 'OAUTH';
  /**
   * For Basic and OAuth authentication: username used to authenticate to the SMTP server
   */
  username: string;
  /**
   * For OAuth authentication: host of the Identity Provider issuing access tokens
   */
  oauthAuthenticationHost?: string;
  /**
   * For OAuth authentication: Microsoft tenant
   */
  oauthTenant?: string;
};

export type EmailConfigurationResource = {
  readonly id?: string;
  /**
   * URL of your SMTP server
   */
  host?: string;
  /**
   * Port of your SMTP server (usually 25, 587 or 465)
   */
  port?: string;
  /**
   * Security protocol used to connect to your SMTP server (SSLTLS is recommended)
   */
  securityProtocol?: 'NONE' | 'SSLTLS' | 'STARTTLS';
  /**
   * Address emails will come from
   */
  fromAddress?: string;
  /**
   * Name emails will come from (usually "SonarQube")
   */
  fromName?: string;
  /**
   * Prefix added to email so they can be easily recognized (usually "[SonarQube]")
   */
  subjectPrefix?: string;
  /**
   * Authentication method used to connect to the SMTP server. OAuth is only supported for Microsoft Exchange
   */
  authMethod?: 'BASIC' | 'OAUTH';
  /**
   * For Basic and OAuth authentication: username used to authenticate to the SMTP server
   */
  username?: string;
  /**
   * For Basic authentication: has the password field been set?
   */
  isBasicPasswordSet?: boolean;
  /**
   * For OAuth authentication: host of the Identity Provider issuing access tokens
   */
  oauthAuthenticationHost?: string;
  /**
   * For OAuth authentication: has the Client ID field been set?
   */
  isOauthClientIdSet?: boolean;
  /**
   * For OAuth authentication: has the Client secret field been set?
   */
  isOauthClientSecretSet?: boolean;
  /**
   * For OAuth authentication: Microsoft tenant
   */
  oauthTenant?: string;
};

export type AwarenessBannerClickedRequest = {
  bannerType?: 'ENABLE' | 'LEARN_MORE';
};

export type AwarenessBannerClickedResponse = {
  readonly id?: string;
};

export type FixSuggestionPostRequest = {
  /**
   * Issue key
   */
  issueId: string;
};

export type ChangeDto = {
  startLine?: number;
  endLine?: number;
  newCode?: string;
};

export type FixSuggestionResponse = {
  id?: string;
  issueId?: string;
  explanation?: string;
  changes?: Array<ChangeDto>;
};

export type GitlabSynchronizationRunResource = {
  readonly id?: string;
};

export type PermissionMappingsPostRequest = {
  /**
   * Custom role name
   */
  role: string;
  permissions: RestPermissions;
};

export type RestPermissions = {
  /**
   * Browse
   */
  user: boolean;
  /**
   * See Source Code
   */
  codeViewer: boolean;
  /**
   * Administer Issues
   */
  issueAdmin: boolean;
  /**
   * Administer Security Hotspots
   */
  securityHotspotAdmin: boolean;
  /**
   * Administer
   */
  admin: boolean;
  /**
   * Execute Analysis
   */
  scan: boolean;
};

export type PermissionMappingsResource = {
  id?: string;
  role?: string;
  baseRole?: boolean;
  permissions?: RestPermissions;
};

export type GitlabConfigurationCreateRestRequest = {
  /**
   * Enable Gitlab authentication
   */
  enabled: boolean;
  /**
   * Gitlab Application id
   */
  applicationId: string;
  /**
   * Url of Gitlab instance for authentication (for instance https://gitlab.com)
   */
  url: string;
  /**
   * Set whether to synchronize groups
   */
  synchronizeGroups: boolean;
  allowedGroups: Array<string>;
  /**
   * Type of synchronization
   */
  provisioningType: 'JIT' | 'AUTO_PROVISIONING';
  /**
   * Allow user to sign up
   */
  allowUsersToSignUp?: boolean;
};

export type GitlabConfigurationResource = {
  readonly id?: string;
  enabled?: boolean;
  /**
   * Gitlab Application id
   */
  applicationId?: string;
  /**
   * Url of Gitlab instance for authentication (for instance https://gitlab.com/api/v4)
   */
  url?: string;
  synchronizeGroups?: boolean;
  /**
   * Root Gitlab groups allowed to authenticate and provisioned
   */
  allowedGroups?: Array<string>;
  allowUsersToSignUp?: boolean;
  provisioningType?: 'JIT' | 'AUTO_PROVISIONING';
  /**
   * Whether or not the provisioningToken is defined
   */
  readonly isProvisioningTokenSet?: boolean;
  /**
   * In case the GitLab configuration is incorrect, error message
   */
  readonly errorMessage?: string;
};

export type GithubConfigurationCreateRestRequest = {
  /**
   * Enable GitHub authentication
   */
  enabled: boolean;
  /**
   * The App ID is found on your GitHub App's page on GitHub at Settings > Developer Settings > GitHub Apps.
   */
  applicationId: string;
  /**
   * Synchronize GitHub team with SonarQube group memberships when users log in to SonarQube.
   * For each GitHub team they belong to, users will be associated to a group of the same name if it exists in SonarQube.
   *
   */
  synchronizeGroups: boolean;
  /**
   * The API url for a GitHub instance. https://api.github.com/ for Github.com, https://github.company.com/api/v3/ when using Github Enterprise
   */
  apiUrl: string;
  /**
   * The WEB url for a GitHub instance. https://github.com/ for Github.com, https://github.company.com/ when using GitHub Enterprise.
   *
   */
  webUrl: string;
  allowedOrganizations: Array<string>;
  /**
   * Type of synchronization
   */
  provisioningType: 'JIT' | 'AUTO_PROVISIONING';
  /**
   * Allow user to sign up
   */
  allowUsersToSignUp?: boolean;
  /**
   * Change project visibility based on GitHub repository visibility.
   * If disabled, every provisioned project will be private in SonarQube and visible only to users with explicit GitHub permissions for the corresponding repository.
   * Changes take effect at the next synchronization.
   *
   */
  projectVisibility?: boolean;
  /**
   * Admin consent to synchronize permissions from GitHub
   */
  userConsentRequiredAfterUpgrade?: boolean;
};

export type GithubConfigurationResource = {
  readonly id?: string;
  enabled?: boolean;
  /**
   * GitHub Application id
   */
  applicationId?: string;
  synchronizeGroups?: boolean;
  /**
   * Url of GitHub instance for API connectivity (for instance https://api.github.com)
   */
  apiUrl?: string;
  /**
   * Url of GitHub instance for authentication (for instance https://github.com)
   */
  webUrl?: string;
  /**
   * GitHub organizations allowed to authenticate and provisioned
   */
  allowedOrganizations?: Array<string>;
  provisioningType?: 'JIT' | 'AUTO_PROVISIONING';
  allowUsersToSignUp?: boolean;
  projectVisibility?: boolean;
  userConsentRequiredAfterUpgrade?: boolean;
  /**
   * In case the GitHub configuration is incorrect, error message
   */
  readonly errorMessage?: string;
};

export type BoundProjectCreateRestRequest = {
  /**
   * Key of the project to create
   */
  projectKey: string;
  /**
   * Name of the project to create
   */
  projectName: string;
  /**
   * Identifier of DevOps platform configuration to use. Use /dop-translation/dop-settings to retrieve the settings and their ID
   */
  devOpsPlatformSettingId: string;
  /**
   * Identifier of the DevOps platform repository to import:
   * - repository slug for GitHub and Bitbucket (Cloud and Server)
   * - repository id for GitLab
   * - repository name for Azure DevOps
   *
   */
  repositoryIdentifier: string;
  /**
   * Identifier of the DevOps platform project in which the repository is located.
   * This is only needed for Azure and BitBucket Server platforms
   *
   */
  projectIdentifier?: string;
  /**
   *   Project New Code Definition Type
   * New code definitions of the following types are allowed:
   * - PREVIOUS_VERSION
   * - NUMBER_OF_DAYS
   * - REFERENCE_BRANCH - will default to the main branch.
   *
   */
  newCodeDefinitionType?: string;
  /**
   *   Project New Code Definition Value
   * For each new code definition type, a different value is expected:
   * - no value, when the new code definition type is PREVIOUS_VERSION and REFERENCE_BRANCH
   * - a number between 1 and 90, when the new code definition type is NUMBER_OF_DAYS
   *
   */
  newCodeDefinitionValue?: string;
  /**
   * True if project is part of a mono repo.
   */
  monorepo: boolean;
};

export type BoundProjectCreateRestResponse = {
  /**
   * The identifier of the created project
   */
  projectId?: string;
  /**
   * The identifier of the binding between the created project and the DevOps platform project
   */
  bindingId?: string;
};

export type Impact = {
  softwareQuality?: 'MAINTAINABILITY' | 'RELIABILITY' | 'SECURITY';
  severity?: 'INFO' | 'LOW' | 'MEDIUM' | 'HIGH' | 'BLOCKER';
};

export type Parameter = {
  key?: string;
  readonly htmlDescription?: string;
  defaultValue?: string;
  type?: 'STRING' | 'TEXT' | 'BOOLEAN' | 'INTEGER' | 'FLOAT';
};

export type RuleCreateRestRequest = {
  /**
   * Key of the custom rule to create, must include the repository
   */
  key: string;
  /**
   * Key of the rule template to be used to create the custom rule
   */
  templateKey: string;
  /**
   * Rule name
   */
  name: string;
  /**
   * Rule description in markdown format
   */
  markdownDescription: string;
  /**
   * Rule status
   */
  status?: 'BETA' | 'DEPRECATED' | 'READY' | 'REMOVED';
  /**
   * Custom rule parameters
   */
  parameters?: Array<Parameter>;
  /**
   * Clean code attribute
   */
  cleanCodeAttribute?:
    | 'CONVENTIONAL'
    | 'FORMATTED'
    | 'IDENTIFIABLE'
    | 'CLEAR'
    | 'COMPLETE'
    | 'EFFICIENT'
    | 'LOGICAL'
    | 'DISTINCT'
    | 'FOCUSED'
    | 'MODULAR'
    | 'TESTED'
    | 'LAWFUL'
    | 'RESPECTFUL'
    | 'TRUSTWORTHY';
  /**
   * Impacts
   */
  impacts: Array<Impact>;
  /**
   * Severity
   */
  severity?: string;
  /**
   * Rule type
   */
  type?: 'CODE_SMELL' | 'BUG' | 'VULNERABILITY' | 'SECURITY_HOTSPOT';
};

export type RuleDescriptionSectionContextRestResponse = {
  key?: string;
  displayName?: string;
};

export type RuleDescriptionSectionRestResponse = {
  readonly key?: string;
  readonly content?: string;
  context?: RuleDescriptionSectionContextRestResponse;
};

export type RuleRestResponse = {
  id?: string;
  key?: string;
  repositoryKey?: string;
  name?: string;
  severity?: string;
  type?: 'CODE_SMELL' | 'BUG' | 'VULNERABILITY' | 'SECURITY_HOTSPOT';
  impacts?: Array<Impact>;
  cleanCodeAttribute?:
    | 'CONVENTIONAL'
    | 'FORMATTED'
    | 'IDENTIFIABLE'
    | 'CLEAR'
    | 'COMPLETE'
    | 'EFFICIENT'
    | 'LOGICAL'
    | 'DISTINCT'
    | 'FOCUSED'
    | 'MODULAR'
    | 'TESTED'
    | 'LAWFUL'
    | 'RESPECTFUL'
    | 'TRUSTWORTHY';
  cleanCodeAttributeCategory?:
    | 'ADAPTABLE'
    | 'CONSISTENT'
    | 'INTENTIONAL'
    | 'RESPONSIBLE';
  status?: 'BETA' | 'DEPRECATED' | 'READY' | 'REMOVED';
  external?: boolean;
  createdAt?: string;
  descriptionSections?: Array<RuleDescriptionSectionRestResponse>;
  markdownDescription?: string;
  gapDescription?: string;
  htmlNote?: string;
  markdownNote?: string;
  educationPrinciples?: Array<string>;
  template?: boolean;
  templateId?: string;
  tags?: Array<string>;
  systemTags?: Array<string>;
  languageKey?: string;
  languageName?: string;
  parameters?: Array<Parameter>;
  remediationFunctionType?: string;
  remediationFunctionGapMultiplier?: string;
  remediationFunctionBaseEffort?: string;
};

export type GroupCreateRestRequest = {
  /**
   * Name for the new group. Must be unique. The value 'anyone' is reserved and cannot be used.
   */
  name: string;
  /**
   * Description for the new group.
   */
  description?: string;
};

export type GroupRestResponse = {
  readonly id?: string;
  name?: string;
  description?: string;
  readonly managed?: boolean;
  readonly default?: boolean;
};

export type GroupMembershipCreateRestRequest = {
  /**
   * ID of the user to add to group.
   */
  userId?: string;
  /**
   * ID of the group where a member needs to be added.
   */
  groupId?: string;
};

export type GroupMembershipRestResponse = {
  readonly id?: string;
  readonly groupId?: string;
  readonly userId?: string;
};

export type UpdateFieldListString = {
  value?: Array<string>;
  defined?: boolean;
};

export type UpdateFieldString = {
  value?: string;
  defined?: boolean;
};

export type UserUpdateRestRequest = {
  login?: UpdateFieldString;
  /**
   * User first name and last name
   */
  name?: string;
  /**
   * Email
   */
  email?: string;
  scmAccounts?: UpdateFieldListString;
  /**
   * New identity provider. Only providers configured in your platform are supported. This could be: github, gitlab, bitbucket, saml, LDAP, LDAP_{serverKey}
   * (according to your server configuration file).
   * Warning: when this is updated, the user will only be able to authenticate using the new identity provider. Also, it is not possible to remove the identity provider of a user.
   *
   */
  externalProvider?: string;
  /**
   * New external login, usually the login used in the authentication system.
   */
  externalLogin?: string;
  /**
   * New external id in the authentication system.
   */
  externalId?: string;
};

export type EmailConfigurationUpdateRestRequest = {
  /**
   * URL of your SMTP server
   */
  host?: string;
  /**
   * Port of your SMTP server (usually 25, 587 or 465)
   */
  port?: string;
  /**
   * Security protocol used to connect to your SMTP server (SSLTLS is recommended)
   */
  securityProtocol?: 'NONE' | 'SSLTLS' | 'STARTTLS';
  /**
   * Address emails will come from
   */
  fromAddress?: string;
  /**
   * Name emails will come from (usually "SonarQube")
   */
  fromName?: string;
  /**
   * Prefix added to email so they can be easily recognized (usually "[SonarQube]")
   */
  subjectPrefix?: string;
  /**
   * Authentication method used to connect to the SMTP server. OAuth is only supported for Microsoft Exchange
   */
  authMethod?: 'BASIC' | 'OAUTH';
  /**
   * For Basic and OAuth authentication: username used to authenticate to the SMTP server
   */
  username?: string;
  /**
   * For basic authentication: password used to authenticate to the SMTP server
   */
  basicPassword?: string;
  /**
   * For OAuth authentication: host of the Identity Provider issuing access tokens
   */
  oauthAuthenticationHost?: string;
  /**
   * For OAuth authentication: Client ID provided by Microsoft Exchange when registering the application
   */
  oauthClientId?: string;
  /**
   * For OAuth authentication: Client password provided by Microsoft Exchange when registering the application
   */
  oauthClientSecret?: string;
  /**
   * For OAuth authentication: Microsoft tenant
   */
  oauthTenant?: string;
};

export type FeatureEnablementRequest = {
  /**
   * Whether SCA is enabled or not
   */
  enablement?: boolean;
};

export type FeatureEnablementResource = {
  enablement?: boolean;
};

export type DevOpsPermissionMappingUpdateRequest = {
  permissions?: PermissionMappingUpdate;
};

export type PermissionMappingUpdate = {
  user?: boolean;
  codeViewer?: boolean;
  issueAdmin?: boolean;
  securityHotspotAdmin?: boolean;
  admin?: boolean;
  scan?: boolean;
};

export type GitlabConfigurationUpdateRestRequest = {
  /**
   * Enable Gitlab authentication
   */
  enabled?: boolean;
  /**
   * Gitlab Application id
   */
  applicationId?: string;
  /**
   * Url of Gitlab instance for authentication (for instance https://gitlab.com/api/v4)
   */
  url?: string;
  /**
   * Secret of the application
   */
  secret?: string;
  /**
   * Set whether to synchronize groups
   */
  synchronizeGroups?: boolean;
  allowedGroups?: UpdateFieldListString;
  /**
   * Type of synchronization
   */
  provisioningType?: 'JIT' | 'AUTO_PROVISIONING';
  /**
   * Allow user to sign up
   */
  allowUsersToSignUp?: boolean;
  /**
   * Gitlab token for provisioning
   */
  provisioningToken?: string;
};

export type GithubConfigurationUpdateRestRequest = {
  /**
   * Enable GitHub authentication
   */
  enabled?: boolean;
  /**
   * GitHub Client ID
   */
  clientId?: string;
  /**
   * GitHub Client secret
   */
  clientSecret?: string;
  /**
   * GitHub Application id
   */
  applicationId?: string;
  /**
   * GitHub Private key
   */
  privateKey?: string;
  /**
   * Set whether to synchronize groups
   */
  synchronizeGroups?: boolean;
  /**
   * Url of GitHub instance for API connectivity (for instance https://api.github.com)
   */
  apiUrl?: string;
  /**
   * Url of GitHub instance for authentication (for instance https://github.com)
   */
  webUrl?: string;
  allowedOrganizations?: UpdateFieldListString;
  /**
   * Type of synchronization
   */
  provisioningType?: 'JIT' | 'AUTO_PROVISIONING';
  /**
   * Allow user to sign up
   */
  allowUsersToSignUp?: boolean;
  /**
   * Sync project visibility
   */
  projectVisibility?: boolean;
  /**
   * Admin consent to synchronize permissions from GitHub
   */
  userConsentRequiredAfterUpgrade?: boolean;
};

export type ModeResource = {
  mode: 'MQR' | 'STANDARD_EXPERIENCE';
  readonly modified?: boolean;
};

export type GroupUpdateRestRequest = {
  /**
   * Group name
   */
  name?: string;
  /**
   * Description of the group
   */
  description?: string;
};

export type PageRestResponse = {
  pageIndex?: number;
  pageSize?: number;
  total?: number;
};

export type UsersSearchRestResponse = {
  users?: Array<UserRestResponseForAdmins>;
  page?: PageRestResponse;
};

export type DatabaseMigrationsResponse = {
  status?: string;
  completedSteps?: number;
  totalSteps?: number;
  startedAt?: string;
  message?: string;
  expectedFinishTimestamp?: string;
};

export type Health = {
  status?: 'GREEN' | 'YELLOW' | 'RED';
  causes?: Array<string>;
};

export type EmailConfigurationSearchRestResponse = {
  emailConfigurations?: Array<EmailConfigurationResource>;
  page?: PageRestResponse;
};

export type ReleaseSearchResource = {
  key?: string;
  packageUrl?: string;
  packageManager?: string;
  packageName?: string;
  version?: string;
  licenseExpression?: string;
  known?: boolean;
  newInPullRequest?: boolean;
  directSummary?: boolean;
  scopeSummary?: string;
  dependencyFilePaths?: Array<string>;
};

export type ReleasesSearchRestResponse = {
  releases?: Array<ReleaseSearchResource>;
  packageManagerCounts?: Array<ScaReleaseByPackageManagerCountDto>;
  page?: PageRestResponse;
};

export type ScaReleaseByPackageManagerCountDto = {
  packageManager?: string;
  releaseCount?: number;
};

export type DependencyResource = {
  key?: string;
  direct?: boolean;
  scope?: string;
  productionScope?: boolean;
  userDependencyFilePath?: string;
  lockfileDependencyFilePath?: string;
  chains?: Array<Array<string>>;
  newInPullRequest?: boolean;
};

export type IssueResource = {
  key?: string;
  severity?: string;
  type?: string;
  createdAt?: string;
  vulnerabilityId?: string;
  cweIds?: Array<string>;
  cvssScore?: string;
  spdxLicenseId?: string;
};

export type ReleaseDetailResource = {
  key?: string;
  packageUrl?: string;
  packageManager?: string;
  packageName?: string;
  version?: string;
  licenseExpression?: string;
  known?: boolean;
  newInPullRequest?: boolean;
  directSummary?: boolean;
  scopeSummary?: string;
  productionScopeSummary?: boolean;
  dependencies?: Array<DependencyResource>;
  issues?: Array<IssueResource>;
};

export type DependencyRiskResource = {
  key?: string;
  severity?: string;
  release?: ReleaseSearchResource;
  type?: string;
  createdAt?: string;
  vulnerabilityId?: string;
  cweIds?: Array<string>;
  cvssScore?: string;
  spdxLicenseId?: string;
};

export type DependencyRisksSearchRestResponse = {
  issuesReleases?: Array<DependencyRiskResource>;
  page?: PageRestResponse;
};

export type AffectedPackageResource = {
  purl?: string;
  recommendation?: string;
  recommendationDetails?: VulnerabilityRecommendationDetailsResource;
  versionOptions?: Array<VersionOptionResource>;
  affectedVersions?: Array<string>;
  unaffectedVersions?: string;
};

export type DependencyRiskDetailsResource = {
  key?: string;
  severity?: string;
  release?: ReleaseSearchResource;
  type?: string;
  createdAt?: string;
  vulnerability?: VulnerabilityResource;
  spdxLicenseId?: string;
};

export type VersionOptionResource = {
  /**
   * The version being presented as an option
   */
  version?: string;
  /**
   * Vulnerability IDs affecting this version
   */
  vulnerabilityIds?: Array<string>;
  /**
   * Is this version a pre-release version
   */
  prerelease?: boolean;
  /**
   * Describes which vulnerabilities are fixed
   */
  fixLevel?: 'COMPLETE' | 'PARTIAL' | 'NONE' | 'UNKNOWN';
  /**
   * How the frontend should label this version
   */
  descriptionCode?:
    | 'VERSION_IN_USE'
    | 'NEAREST_PARTIAL'
    | 'NEAREST_COMPLETE'
    | 'LATEST_PARTIAL'
    | 'LATEST_COMPLETE'
    | 'LATEST_STABLE'
    | 'LATEST_PRERELEASE'
    | 'UNKNOWN';
};

export type VulnerabilityRecommendationDetailsResource = {
  impactScore?: number;
  impactDescription?: string;
  realIssue?: boolean;
  falsePositiveReason?: string;
  includesDev?: boolean;
  specificMethodsAffected?: boolean;
  specificMethodsDescription?: string;
  otherConditions?: boolean;
  otherConditionsDescription?: string;
  workaroundAvailable?: boolean;
  workaroundDescription?: string;
  visibility?: string;
};

export type VulnerabilityReportResource = {
  id?: string;
  url?: string;
  type?: string;
  cvssScore?: string;
  cvssSeverity?: string;
};

export type VulnerabilityResource = {
  vulnerabilityId?: string;
  reports?: Array<VulnerabilityReportResource>;
  description?: string;
  epssPercentile?: string;
  epssProbability?: string;
  knownExploited?: boolean;
  cweIds?: Array<string>;
  affectedPackages?: Array<AffectedPackageResource>;
};

export type ScaCliInfoRestResponse = {
  id?: string;
  filename?: string;
  sha256?: string;
  os?: string;
  arch?: string;
};

export type LlmModelDto = {
  key?: string;
  name?: string;
  recommended?: boolean;
};

export type LlmProviderResponseDto = {
  key?: string;
  name?: string;
  selfHosted?: boolean;
  models?: Array<LlmModelDto>;
};

export type ServiceInfo = {
  status?:
    | 'CONNECTION_ERROR'
    | 'SERVICE_ERROR'
    | 'SUCCESS'
    | 'TIMEOUT'
    | 'UNAUTHORIZED';
  isEnabled?: boolean;
  subscriptionType?: 'EARLY_ACCESS' | 'PAID' | 'NOT_PAID';
};

export type SubscriptionTypeResponse = {
  subscriptionType?: 'EARLY_ACCESS' | 'PAID' | 'NOT_PAID';
};

export type FixSuggestionIssueResponse = {
  issueId?: string;
  aiSuggestion?:
    | 'AVAILABLE'
    | 'NOT_AVAILABLE_FILE_LEVEL_ISSUE'
    | 'NOT_AVAILABLE_UNSUPPORTED_RULE'
    | 'NOT_AVAILABLE_FILE_SIZE';
};

export type FeatureEnablementResponse = {
  enablement?:
    | 'DISABLED'
    | 'ENABLED_FOR_ALL_PROJECTS'
    | 'ENABLED_FOR_SOME_PROJECTS';
  enabledProjectKeys?: Array<string>;
  provider?: ProviderResponseDto;
};

export type ProviderResponseDto = {
  key?: string;
  modelKey?: string;
  endpoint?: string;
};

export type ProjectBinding = {
  id: string;
  devOpsPlatformSettingId: string;
  projectId: string;
  projectKey: string;
  repository?: string;
  slug?: string;
};

export type ProjectBindingsSearchRestResponse = {
  projectBindings?: Array<ProjectBinding>;
  page?: PageRestResponse;
};

export type PermissionMappingsSearchRestResponse = {
  permissionMappings?: Array<PermissionMappingsResource>;
};

export type GitlabConfigurationSearchRestResponse = {
  gitlabConfigurations?: Array<GitlabConfigurationResource>;
  page?: PageRestResponse;
};

export type GithubConfigurationSearchRestResponse = {
  githubConfigurations?: Array<GithubConfigurationResource>;
  page?: PageRestResponse;
};

export type DopSettingsResource = {
  readonly id?: string;
  /**
   * Supported DevOps Platform are: github, gitlab, azure, bitbucketcloud, bitbucket_server
   */
  type?: string;
  key?: string;
  url?: string;
  appId?: string;
};

export type DopSettingsRestResponse = {
  dopSettings?: Array<DopSettingsResource>;
  page?: PageRestResponse;
};

export type GroupsSearchRestResponse = {
  groups?: Array<GroupRestResponse>;
  page?: PageRestResponse;
};

export type GroupsMembershipSearchRestResponse = {
  groupMemberships?: Array<GroupMembershipRestResponse>;
  page?: PageRestResponse;
};

export type JreInfoRestResponse = {
  id?: string;
  filename?: string;
  sha256?: string;
  javaPath?: string;
  os?: string;
  arch?: string;
};

export type EngineInfoRestResponse = {
  filename?: string;
  sha256?: string;
};

export type ActiveRule = {
  ruleKey?: RuleKey;
  name?: string;
  severity?: string;
  createdAt?: string;
  updatedAt?: string;
  internalKey?: string;
  language?: string;
  templateRuleKey?: string;
  qProfileKey?: string;
  deprecatedKeys?: Array<RuleKey>;
  params?: Array<Param>;
  impacts?: {
    [key: string]: 'INFO' | 'LOW' | 'MEDIUM' | 'HIGH' | 'BLOCKER';
  };
};

export type Param = {
  key?: string;
  value?: string;
};

export type RuleKey = {
  repository?: string;
  rule?: string;
};

/**
 * Metric for a component
 * A metric captured from a project
 */
export type Metric = {
  key: string;
  name: string;
  type: string;
  domain: string;
  hidden: boolean;
  description: string;
  qualitative: boolean;
  higherValuesAreBetter: boolean;
};

/**
 * Used to represent a paged response
 */
export type Paging = {
  total: number;
  pageSize: number;
  pageIndex: number;
};

/**
 * Measures from a project
 */
export type Measure = {
  value: string;
  metric: string;
  period: {
    value: boolean;
    bestValue: string;
  };
};

/**
 * A component is a representation of a Project in Sonarqube
 */
export type Component = {
  key: string;
  name: string;
  managed: string;
  revision: string;
  qualifier: string;
  visibility: string;
  lastAnalysisDate: string;
};

/**
 * Issue Search Response
 * Response object from the Issue Search API
 */
export type IssueSearchResponse = {
  rules: Array<{
    key: string;
    lang: string;
    name: string;
    status: string;
    langName: string;
  }>;
  users: Array<{
    name: string;
    login: string;
    active: boolean;
    avatar: string;
  }>;
  facets: Array<{
    values: Array<{
      val: string;
      count: number;
    }>;
    property: string;
  }>;
  issues: Array<{
    key: string;
    attr: {
      'jira-issue-key': string;
    };
    hash: string;
    line: number;
    rule: string;
    tags: Array<string>;
    type: string;
    flows: Array<{
      locations: Array<{
        msg: string;
        textRange: {
          endLine: number;
          endOffset: number;
          startLine: number;
          startOffset: number;
        };
        msgFormattings: Array<{
          end: number;
          type: string;
          start: number;
        }>;
      }>;
    }>;
    author: string;
    effort: string;
    status: string;
    actions: Array<string>;
    impacts: Array<{
      severity: string;
      softwareQuality: string;
    }>;
    message: string;
    project: string;
    comments: Array<{
      key: string;
      login: string;
      htmlText: string;
      markdown: string;
      createdAt: string;
      updatable: boolean;
    }>;
    severity: string;
    component: string;
    textRange: {
      endLine: number;
      endOffset: number;
      startLine: number;
      startOffset: number;
    };
    updateDate: string;
    issueStatus: string;
    transitions: Array<string>;
    codeVariants: Array<string>;
    creationDate: string;
    prioritizedRule: boolean;
    quickFixAvailable: boolean;
    cleanCodeAttribute: string;
    messageFormattings: Array<{
      end: number;
      type: string;
      start: number;
    }>;
    ruleDescriptionContextKey: string;
    cleanCodeAttributeCategory: string;
  }>;
  paging: Paging;
  components: Array<{
    key: string;
    name: string;
    path?: string;
    enabled: boolean;
    longName: string;
    qualifier: string;
  }>;
};

/**
 * Response type for searching for a project
 */
export type ProjectSearchResponse = {
  paging: Paging;
  components: Array<Component>;
};

/**
 * Generated schema for Root
 * Response from the /measures/component endpoint
 */
export type MeasureComponentResponse = {
  period: {
    date: string;
    mode: string;
    parameter: string;
  };
  metrics: Array<Metric>;
  component: {
    key: string;
    name: string;
    path: string;
    language: string;
    measures: Array<Measure>;
    qualifier: string;
  };
};

/**
 * User Token Details
 * A user token
 */
export type UserTokenDetails = {
  /**
   * Token name
   */
  name: string;
  /**
   * Token creation date
   */
  createdAt: Date;
  /**
   * Last date the token was used
   */
  lastConnectionDate?: Date;
  /**
   * Token expiration date
   */
  expirationDate?: Date;
  /**
   * Token type
   */
  type?: 'USER_TOKEN' | 'GLOBAL_ANALYSIS_TOKEN' | 'PROJECT_ANALYSIS_TOKEN';
  /**
   * Project key for PROJECT_ANALYSIS_TOKEN
   */
  projectKey?: string;
  /**
   * Project name for PROJECT_ANALYSIS_TOKEN
   */
  projectName?: string;
};

/**
 * User Token Search Response
 * Response from the user token search endpoint
 */
export type UserTokenSearchResponse = {
  /**
   * User login
   */
  login?: string;
  userTokens: Array<UserTokenDetails>;
};

/**
 * User Token Generate Response
 * Response from the user token generate endpoint
 */
export type UserTokenGenerateResponse = {
  /**
   * Token name
   */
  name: string;
  /**
   * The generated token value (only returned once)
   */
  token: string;
  /**
   * Token creation date
   */
  createdAt: Date;
  /**
   * User login
   */
  login?: string;
  /**
   * Token type
   */
  type?: 'USER_TOKEN' | 'GLOBAL_ANALYSIS_TOKEN' | 'PROJECT_ANALYSIS_TOKEN';
  /**
   * Project key for PROJECT_ANALYSIS_TOKEN
   */
  projectKey?: string;
  /**
   * Project name for PROJECT_ANALYSIS_TOKEN
   */
  projectName?: string;
  /**
   * Token expiration date
   */
  expirationDate?: Date;
};

export type UserCreateRestRequestWritable = {
  /**
   * User email
   */
  email?: string;
  /**
   * Specify if the user should be authenticated from SonarQube server or from an external authentication system. Password should not be set when local is set to false.
   */
  local?: boolean;
  /**
   * User login
   */
  login: string;
  /**
   * User name
   */
  name: string;
  /**
   * User password. Only mandatory when creating local user, otherwise it should not be set
   */
  password?: string;
  /**
   * List of SCM accounts.
   */
  scmAccounts?: Array<string>;
};

export type UserRestResponseForAdminsWritable = {
  login?: string;
  name?: string;
  email?: string;
  externalLogin?: string;
  externalProvider?: string;
  externalId?: string;
  avatar?: string;
  scmAccounts?: Array<string>;
};

export type EmailConfigurationCreateRestRequestWritable = {
  /**
   * URL of your SMTP server
   */
  host: string;
  /**
   * Port of your SMTP server (usually 25, 587 or 465)
   */
  port: string;
  /**
   * Security protocol used to connect to your SMTP server (SSLTLS is recommended)
   */
  securityProtocol: 'NONE' | 'SSLTLS' | 'STARTTLS';
  /**
   * Address emails will come from
   */
  fromAddress: string;
  /**
   * Name emails will come from (usually "SonarQube")
   */
  fromName: string;
  /**
   * Prefix added to email so they can be easily recognized (usually "[SonarQube]")
   */
  subjectPrefix: string;
  /**
   * Authentication method used to connect to the SMTP server. OAuth is only supported for Microsoft Exchange
   */
  authMethod: 'BASIC' | 'OAUTH';
  /**
   * For Basic and OAuth authentication: username used to authenticate to the SMTP server
   */
  username: string;
  /**
   * For basic authentication: password used to authenticate to the SMTP server
   */
  basicPassword?: string;
  /**
   * For OAuth authentication: host of the Identity Provider issuing access tokens
   */
  oauthAuthenticationHost?: string;
  /**
   * For OAuth authentication: Client ID provided by Microsoft Exchange when registering the application
   */
  oauthClientId?: string;
  /**
   * For OAuth authentication: Client secret provided by Microsoft Exchange when registering the application
   */
  oauthClientSecret?: string;
  /**
   * For OAuth authentication: Microsoft tenant
   */
  oauthTenant?: string;
};

export type EmailConfigurationResourceWritable = {
  /**
   * URL of your SMTP server
   */
  host?: string;
  /**
   * Port of your SMTP server (usually 25, 587 or 465)
   */
  port?: string;
  /**
   * Security protocol used to connect to your SMTP server (SSLTLS is recommended)
   */
  securityProtocol?: 'NONE' | 'SSLTLS' | 'STARTTLS';
  /**
   * Address emails will come from
   */
  fromAddress?: string;
  /**
   * Name emails will come from (usually "SonarQube")
   */
  fromName?: string;
  /**
   * Prefix added to email so they can be easily recognized (usually "[SonarQube]")
   */
  subjectPrefix?: string;
  /**
   * Authentication method used to connect to the SMTP server. OAuth is only supported for Microsoft Exchange
   */
  authMethod?: 'BASIC' | 'OAUTH';
  /**
   * For Basic and OAuth authentication: username used to authenticate to the SMTP server
   */
  username?: string;
  /**
   * For Basic authentication: has the password field been set?
   */
  isBasicPasswordSet?: boolean;
  /**
   * For OAuth authentication: host of the Identity Provider issuing access tokens
   */
  oauthAuthenticationHost?: string;
  /**
   * For OAuth authentication: has the Client ID field been set?
   */
  isOauthClientIdSet?: boolean;
  /**
   * For OAuth authentication: has the Client secret field been set?
   */
  isOauthClientSecretSet?: boolean;
  /**
   * For OAuth authentication: Microsoft tenant
   */
  oauthTenant?: string;
};

export type GitlabConfigurationCreateRestRequestWritable = {
  /**
   * Enable Gitlab authentication
   */
  enabled: boolean;
  /**
   * Gitlab Application id
   */
  applicationId: string;
  /**
   * Url of Gitlab instance for authentication (for instance https://gitlab.com)
   */
  url: string;
  /**
   * Secret of the application
   */
  secret: string;
  /**
   * Set whether to synchronize groups
   */
  synchronizeGroups: boolean;
  allowedGroups: Array<string>;
  /**
   * Type of synchronization
   */
  provisioningType: 'JIT' | 'AUTO_PROVISIONING';
  /**
   * Gitlab token for provisioning
   */
  provisioningToken?: string;
  /**
   * Allow user to sign up
   */
  allowUsersToSignUp?: boolean;
};

export type GitlabConfigurationResourceWritable = {
  enabled?: boolean;
  /**
   * Gitlab Application id
   */
  applicationId?: string;
  /**
   * Url of Gitlab instance for authentication (for instance https://gitlab.com/api/v4)
   */
  url?: string;
  synchronizeGroups?: boolean;
  /**
   * Root Gitlab groups allowed to authenticate and provisioned
   */
  allowedGroups?: Array<string>;
  allowUsersToSignUp?: boolean;
  provisioningType?: 'JIT' | 'AUTO_PROVISIONING';
};

export type GithubConfigurationCreateRestRequestWritable = {
  /**
   * Enable GitHub authentication
   */
  enabled: boolean;
  /**
   * Client ID provided by GitHub when registering the application.
   */
  clientId: string;
  /**
   * Client password provided by GitHub when registering the application.
   */
  clientSecret: string;
  /**
   * The App ID is found on your GitHub App's page on GitHub at Settings > Developer Settings > GitHub Apps.
   */
  applicationId: string;
  /**
   * Your GitHub App's private key. You can generate a .pem file from your GitHub App's page under Private keys.
   * Copy and paste the whole contents of the file here.
   *
   */
  privateKey: string;
  /**
   * Synchronize GitHub team with SonarQube group memberships when users log in to SonarQube.
   * For each GitHub team they belong to, users will be associated to a group of the same name if it exists in SonarQube.
   *
   */
  synchronizeGroups: boolean;
  /**
   * The API url for a GitHub instance. https://api.github.com/ for Github.com, https://github.company.com/api/v3/ when using Github Enterprise
   */
  apiUrl: string;
  /**
   * The WEB url for a GitHub instance. https://github.com/ for Github.com, https://github.company.com/ when using GitHub Enterprise.
   *
   */
  webUrl: string;
  allowedOrganizations: Array<string>;
  /**
   * Type of synchronization
   */
  provisioningType: 'JIT' | 'AUTO_PROVISIONING';
  /**
   * Allow user to sign up
   */
  allowUsersToSignUp?: boolean;
  /**
   * Change project visibility based on GitHub repository visibility.
   * If disabled, every provisioned project will be private in SonarQube and visible only to users with explicit GitHub permissions for the corresponding repository.
   * Changes take effect at the next synchronization.
   *
   */
  projectVisibility?: boolean;
  /**
   * Admin consent to synchronize permissions from GitHub
   */
  userConsentRequiredAfterUpgrade?: boolean;
};

export type GithubConfigurationResourceWritable = {
  enabled?: boolean;
  /**
   * GitHub Application id
   */
  applicationId?: string;
  synchronizeGroups?: boolean;
  /**
   * Url of GitHub instance for API connectivity (for instance https://api.github.com)
   */
  apiUrl?: string;
  /**
   * Url of GitHub instance for authentication (for instance https://github.com)
   */
  webUrl?: string;
  /**
   * GitHub organizations allowed to authenticate and provisioned
   */
  allowedOrganizations?: Array<string>;
  provisioningType?: 'JIT' | 'AUTO_PROVISIONING';
  allowUsersToSignUp?: boolean;
  projectVisibility?: boolean;
  userConsentRequiredAfterUpgrade?: boolean;
};

export type ParameterWritable = {
  key?: string;
  defaultValue?: string;
};

export type RuleDescriptionSectionRestResponseWritable = {
  [key: string]: unknown;
};

export type GroupRestResponseWritable = {
  name?: string;
  description?: string;
};

export type ModeResourceWritable = {
  mode: 'MQR' | 'STANDARD_EXPERIENCE';
};

export type DopSettingsResourceWritable = {
  /**
   * Supported DevOps Platform are: github, gitlab, azure, bitbucketcloud, bitbucket_server
   */
  type?: string;
  key?: string;
  url?: string;
  appId?: string;
};

export type GroupsMembershipSearchRestResponseWritable = {
  groupMemberships?: Array<unknown>;
  page?: PageRestResponse;
};

/**
 * Current page
 */
export type P = number;

/**
 * Page size. Must be greater than 0 and less or equal than 500
 */
export type Ps = bigint;

export type SearchData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Return active/inactive users
     */
    active?: boolean;
    /**
     * Return managed or non-managed users. Only available for managed instances, throws for non-managed instances
     */
    managed?: boolean;
    /**
     * Filter on login, name and email.
     * This parameter performs a partial match (contains), it is case insensitive.
     */
    q?: string;
    /**
     * Filter on externalIdentity.
     * This parameter perform a case-sensitive exact match
     */
    externalIdentity?: string;
    /**
     * Filter users based on the last connection date field. Only users who interacted with this instance at or after the date will be returned. The format must be ISO 8601 datetime format (YYYY-MM-DDThh:mm:ss±hhmm)
     */
    sonarQubeLastConnectionDateFrom?: string;
    /**
     * Filter users based on the last connection date field. Only users that never connected or who interacted with this instance at or before the date will be returned. The format must be ISO 8601 datetime format (YYYY-MM-DDThh:mm:ss±hhmm)
     */
    sonarQubeLastConnectionDateTo?: string;
    /**
     * Filter users based on the SonarLint last connection date field Only users who interacted with this instance using SonarLint at or after the date will be returned. The format must be ISO 8601 datetime format (YYYY-MM-DDThh:mm:ss±hhmm)
     */
    sonarLintLastConnectionDateFrom?: string;
    /**
     * Filter users based on the SonarLint last connection date field. Only users that never connected or who interacted with this instance using SonarLint at or before the date will be returned. The format must be ISO 8601 datetime format (YYYY-MM-DDThh:mm:ss±hhmm)
     */
    sonarLintLastConnectionDateTo?: string;
    /**
     * Filter users belonging to group. Only available for system administrators. Using != operator will exclude users from this group.
     */
    groupId?: string;
    /**
     * Number of results per page. A value of 0 will only return the pagination information.
     */
    pageSize?: number;
    /**
     * 1-based page index
     */
    pageIndex?: number;
  };
  url: '/v2/users-management/users';
};

export type SearchResponses = {
  /**
   * OK
   */
  200: UsersSearchRestResponse;
};

export type SearchResponse = SearchResponses[keyof SearchResponses];

export type CreateData = {
  body: UserCreateRestRequestWritable;
  path?: never;
  query?: never;
  url: '/v2/users-management/users';
};

export type CreateResponses = {
  /**
   * OK
   */
  200: UserRestResponseForAdmins;
};

export type CreateResponse = CreateResponses[keyof CreateResponses];

export type SearchEmailConfigurationsData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/system/email-configurations';
};

export type SearchEmailConfigurationsResponses = {
  /**
   * OK
   */
  200: EmailConfigurationSearchRestResponse;
};

export type SearchEmailConfigurationsResponse =
  SearchEmailConfigurationsResponses[keyof SearchEmailConfigurationsResponses];

export type CreateEmailConfigurationData = {
  body: EmailConfigurationCreateRestRequestWritable;
  path?: never;
  query?: never;
  url: '/v2/system/email-configurations';
};

export type CreateEmailConfigurationResponses = {
  /**
   * OK
   */
  200: EmailConfigurationResource;
};

export type CreateEmailConfigurationResponse =
  CreateEmailConfigurationResponses[keyof CreateEmailConfigurationResponses];

export type CreateAwarenessBannerClickedData = {
  body: AwarenessBannerClickedRequest;
  path?: never;
  query?: never;
  url: '/v2/fix-suggestions/feature-enablements/awareness-banner-interactions';
};

export type CreateAwarenessBannerClickedResponses = {
  /**
   * OK
   */
  200: AwarenessBannerClickedResponse;
};

export type CreateAwarenessBannerClickedResponse =
  CreateAwarenessBannerClickedResponses[keyof CreateAwarenessBannerClickedResponses];

export type Create1Data = {
  body: FixSuggestionPostRequest;
  path?: never;
  query?: never;
  url: '/v2/fix-suggestions/ai-suggestions';
};

export type Create1Responses = {
  /**
   * OK
   */
  200: FixSuggestionResponse;
};

export type Create1Response = Create1Responses[keyof Create1Responses];

export type Create2Data = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/dop-translation/gitlab-synchronization-runs';
};

export type Create2Responses = {
  /**
   * OK
   */
  200: GitlabSynchronizationRunResource;
};

export type Create2Response = Create2Responses[keyof Create2Responses];

export type FetchAllData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/dop-translation/gitlab-permission-mappings';
};

export type FetchAllResponses = {
  /**
   * OK
   */
  200: PermissionMappingsSearchRestResponse;
};

export type FetchAllResponse = FetchAllResponses[keyof FetchAllResponses];

export type CreateMappingData = {
  body: PermissionMappingsPostRequest;
  path?: never;
  query?: never;
  url: '/v2/dop-translation/gitlab-permission-mappings';
};

export type CreateMappingResponses = {
  /**
   * OK
   */
  200: PermissionMappingsResource;
};

export type CreateMappingResponse =
  CreateMappingResponses[keyof CreateMappingResponses];

export type SearchGitlabConfigurationData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/dop-translation/gitlab-configurations';
};

export type SearchGitlabConfigurationResponses = {
  /**
   * OK
   */
  200: GitlabConfigurationSearchRestResponse;
};

export type SearchGitlabConfigurationResponse =
  SearchGitlabConfigurationResponses[keyof SearchGitlabConfigurationResponses];

export type Create3Data = {
  body: GitlabConfigurationCreateRestRequestWritable;
  path?: never;
  query?: never;
  url: '/v2/dop-translation/gitlab-configurations';
};

export type Create3Responses = {
  /**
   * OK
   */
  200: GitlabConfigurationResource;
};

export type Create3Response = Create3Responses[keyof Create3Responses];

export type FetchAll1Data = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/dop-translation/github-permission-mappings';
};

export type FetchAll1Responses = {
  /**
   * OK
   */
  200: PermissionMappingsSearchRestResponse;
};

export type FetchAll1Response = FetchAll1Responses[keyof FetchAll1Responses];

export type CreateMapping1Data = {
  body: PermissionMappingsPostRequest;
  path?: never;
  query?: never;
  url: '/v2/dop-translation/github-permission-mappings';
};

export type CreateMapping1Responses = {
  /**
   * OK
   */
  200: PermissionMappingsResource;
};

export type CreateMapping1Response =
  CreateMapping1Responses[keyof CreateMapping1Responses];

export type SearchGithubConfigurationData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/dop-translation/github-configurations';
};

export type SearchGithubConfigurationResponses = {
  /**
   * OK
   */
  200: GithubConfigurationSearchRestResponse;
};

export type SearchGithubConfigurationResponse =
  SearchGithubConfigurationResponses[keyof SearchGithubConfigurationResponses];

export type CreateGithubConfigurationData = {
  body: GithubConfigurationCreateRestRequestWritable;
  path?: never;
  query?: never;
  url: '/v2/dop-translation/github-configurations';
};

export type CreateGithubConfigurationResponses = {
  /**
   * OK
   */
  200: GithubConfigurationResource;
};

export type CreateGithubConfigurationResponse =
  CreateGithubConfigurationResponses[keyof CreateGithubConfigurationResponses];

export type CreateBoundProjectData = {
  body: BoundProjectCreateRestRequest;
  path?: never;
  query?: never;
  url: '/v2/dop-translation/bound-projects';
};

export type CreateBoundProjectResponses = {
  /**
   * Created
   */
  201: BoundProjectCreateRestResponse;
};

export type CreateBoundProjectResponse =
  CreateBoundProjectResponses[keyof CreateBoundProjectResponses];

export type Create4Data = {
  body: RuleCreateRestRequest;
  path?: never;
  query?: never;
  url: '/v2/clean-code-policy/rules';
};

export type Create4Responses = {
  /**
   * OK
   */
  200: RuleRestResponse;
};

export type Create4Response = Create4Responses[keyof Create4Responses];

export type Search1Data = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Return managed or non-managed groups. Only available for managed instances, throws for non-managed instances
     */
    managed?: boolean;
    /**
     * Filter on name.
     * This parameter performs a partial match (contains), it is case insensitive.
     */
    q?: string;
    /**
     * Number of results per page. A value of 0 will only return the pagination information.
     */
    pageSize?: number;
    /**
     * 1-based page index
     */
    pageIndex?: number;
  };
  url: '/v2/authorizations/groups';
};

export type Search1Responses = {
  /**
   * OK
   */
  200: GroupsSearchRestResponse;
};

export type Search1Response = Search1Responses[keyof Search1Responses];

export type Create5Data = {
  body: GroupCreateRestRequest;
  path?: never;
  query?: never;
  url: '/v2/authorizations/groups';
};

export type Create5Responses = {
  /**
   * Created
   */
  201: GroupRestResponse;
};

export type Create5Response = Create5Responses[keyof Create5Responses];

export type Search2Data = {
  body?: never;
  path?: never;
  query?: {
    /**
     * ID of the user for which to search groups. If not set, all groups are returned.
     */
    userId?: string;
    /**
     * ID of the group for which to search members. If not set, all groups are returned.
     */
    groupId?: string;
    /**
     * Number of results per page. A value of 0 will only return the pagination information.
     */
    pageSize?: number;
    /**
     * 1-based page index
     */
    pageIndex?: number;
  };
  url: '/v2/authorizations/group-memberships';
};

export type Search2Responses = {
  /**
   * OK
   */
  200: GroupsMembershipSearchRestResponse;
};

export type Search2Response = Search2Responses[keyof Search2Responses];

export type Create6Data = {
  body: GroupMembershipCreateRestRequest;
  path?: never;
  query?: never;
  url: '/v2/authorizations/group-memberships';
};

export type Create6Responses = {
  /**
   * Created
   */
  201: GroupMembershipRestResponse;
};

export type Create6Response = Create6Responses[keyof Create6Responses];

export type DeactivateData = {
  body?: never;
  path: {
    /**
     * The ID of the user to delete.
     */
    id: string;
  };
  query?: {
    /**
     * Anonymize user in addition to deactivating it.
     */
    anonymize?: boolean;
  };
  url: '/v2/users-management/users/{id}';
};

export type DeactivateResponses = {
  /**
   * No Content
   */
  204: void;
};

export type DeactivateResponse = DeactivateResponses[keyof DeactivateResponses];

export type FetchUserData = {
  body?: never;
  path: {
    /**
     * The id of the user to fetch.
     */
    id: string;
  };
  query?: never;
  url: '/v2/users-management/users/{id}';
};

export type FetchUserResponses = {
  /**
   * OK
   */
  200: UserRestResponseForAdmins;
};

export type FetchUserResponse = FetchUserResponses[keyof FetchUserResponses];

export type UpdateUserData = {
  body: UserUpdateRestRequest;
  path: {
    id: string;
  };
  query?: never;
  url: '/v2/users-management/users/{id}';
};

export type UpdateUserResponses = {
  /**
   * OK
   */
  200: UserRestResponseForAdmins;
};

export type UpdateUserResponse = UpdateUserResponses[keyof UpdateUserResponses];

export type DeleteEmailConfigurationData = {
  body?: never;
  path: {
    /**
     * The id of the configuration to delete.
     */
    id: string;
  };
  query?: never;
  url: '/v2/system/email-configurations/{id}';
};

export type DeleteEmailConfigurationResponses = {
  /**
   * No Content
   */
  204: void;
};

export type DeleteEmailConfigurationResponse =
  DeleteEmailConfigurationResponses[keyof DeleteEmailConfigurationResponses];

export type GetEmailConfigurationData = {
  body?: never;
  path: {
    /**
     * The id of the configuration to fetch.
     */
    id: string;
  };
  query?: never;
  url: '/v2/system/email-configurations/{id}';
};

export type GetEmailConfigurationResponses = {
  /**
   * OK
   */
  200: EmailConfigurationResource;
};

export type GetEmailConfigurationResponse =
  GetEmailConfigurationResponses[keyof GetEmailConfigurationResponses];

export type UpdateEmailConfigurationData = {
  body: EmailConfigurationUpdateRestRequest;
  path: {
    id: string;
  };
  query?: never;
  url: '/v2/system/email-configurations/{id}';
};

export type UpdateEmailConfigurationResponses = {
  /**
   * OK
   */
  200: EmailConfigurationResource;
};

export type UpdateEmailConfigurationResponse =
  UpdateEmailConfigurationResponses[keyof UpdateEmailConfigurationResponses];

export type GetFeatureEnablementData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/sca/feature-enablements';
};

export type GetFeatureEnablementResponses = {
  /**
   * OK
   */
  200: FeatureEnablementResource;
};

export type GetFeatureEnablementResponse =
  GetFeatureEnablementResponses[keyof GetFeatureEnablementResponses];

export type UpdateFeatureEnablementData = {
  body: FeatureEnablementRequest;
  path?: never;
  query?: never;
  url: '/v2/sca/feature-enablements';
};

export type UpdateFeatureEnablementResponses = {
  /**
   * OK
   */
  200: FeatureEnablementResource;
};

export type UpdateFeatureEnablementResponse =
  UpdateFeatureEnablementResponses[keyof UpdateFeatureEnablementResponses];

export type GetFeatureEnablement1Data = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/fix-suggestions/feature-enablements';
};

export type GetFeatureEnablement1Responses = {
  /**
   * OK
   */
  200: FeatureEnablementResponse;
};

export type GetFeatureEnablement1Response =
  GetFeatureEnablement1Responses[keyof GetFeatureEnablement1Responses];

export type UpdateFeatureEnablement1Data = {
  body: FeatureEnablementRequest;
  path?: never;
  query?: never;
  url: '/v2/fix-suggestions/feature-enablements';
};

export type UpdateFeatureEnablement1Responses = {
  /**
   * No Content
   */
  204: void;
};

export type UpdateFeatureEnablement1Response =
  UpdateFeatureEnablement1Responses[keyof UpdateFeatureEnablement1Responses];

export type DeleteMappingData = {
  body?: never;
  path: {
    /**
     * The name of the role to delete
     */
    role: string;
  };
  query?: never;
  url: '/v2/dop-translation/gitlab-permission-mappings/{role}';
};

export type DeleteMappingResponses = {
  /**
   * No Content
   */
  204: void;
};

export type DeleteMappingResponse =
  DeleteMappingResponses[keyof DeleteMappingResponses];

export type UpdateMappingData = {
  body: DevOpsPermissionMappingUpdateRequest;
  path: {
    /**
     * The name of the role to update
     */
    role: string;
  };
  query?: never;
  url: '/v2/dop-translation/gitlab-permission-mappings/{role}';
};

export type UpdateMappingResponses = {
  /**
   * OK
   */
  200: PermissionMappingsResource;
};

export type UpdateMappingResponse =
  UpdateMappingResponses[keyof UpdateMappingResponses];

export type DeleteGitlabConfigurationData = {
  body?: never;
  path: {
    /**
     * The id of the configuration to delete.
     */
    id: string;
  };
  query?: never;
  url: '/v2/dop-translation/gitlab-configurations/{id}';
};

export type DeleteGitlabConfigurationResponses = {
  /**
   * No Content
   */
  204: void;
};

export type DeleteGitlabConfigurationResponse =
  DeleteGitlabConfigurationResponses[keyof DeleteGitlabConfigurationResponses];

export type GetGitlabConfigurationData = {
  body?: never;
  path: {
    /**
     * The id of the configuration to fetch.
     */
    id: string;
  };
  query?: never;
  url: '/v2/dop-translation/gitlab-configurations/{id}';
};

export type GetGitlabConfigurationResponses = {
  /**
   * OK
   */
  200: GitlabConfigurationResource;
};

export type GetGitlabConfigurationResponse =
  GetGitlabConfigurationResponses[keyof GetGitlabConfigurationResponses];

export type UpdateGitlabConfigurationData = {
  body: GitlabConfigurationUpdateRestRequest;
  path: {
    id: string;
  };
  query?: never;
  url: '/v2/dop-translation/gitlab-configurations/{id}';
};

export type UpdateGitlabConfigurationResponses = {
  /**
   * OK
   */
  200: GitlabConfigurationResource;
};

export type UpdateGitlabConfigurationResponse =
  UpdateGitlabConfigurationResponses[keyof UpdateGitlabConfigurationResponses];

export type DeleteMapping1Data = {
  body?: never;
  path: {
    /**
     * The name of the role to delete
     */
    role: string;
  };
  query?: never;
  url: '/v2/dop-translation/github-permission-mappings/{role}';
};

export type DeleteMapping1Responses = {
  /**
   * No Content
   */
  204: void;
};

export type DeleteMapping1Response =
  DeleteMapping1Responses[keyof DeleteMapping1Responses];

export type UpdateMapping1Data = {
  body: DevOpsPermissionMappingUpdateRequest;
  path: {
    /**
     * The name of the role to update
     */
    role: string;
  };
  query?: never;
  url: '/v2/dop-translation/github-permission-mappings/{role}';
};

export type UpdateMapping1Responses = {
  /**
   * OK
   */
  200: PermissionMappingsResource;
};

export type UpdateMapping1Response =
  UpdateMapping1Responses[keyof UpdateMapping1Responses];

export type DeleteGithubConfigurationData = {
  body?: never;
  path: {
    /**
     * The id of the configuration to delete.
     */
    id: string;
  };
  query?: never;
  url: '/v2/dop-translation/github-configurations/{id}';
};

export type DeleteGithubConfigurationResponses = {
  /**
   * No Content
   */
  204: void;
};

export type DeleteGithubConfigurationResponse =
  DeleteGithubConfigurationResponses[keyof DeleteGithubConfigurationResponses];

export type GetGithubConfigurationData = {
  body?: never;
  path: {
    /**
     * The id of the configuration to fetch.
     */
    id: string;
  };
  query?: never;
  url: '/v2/dop-translation/github-configurations/{id}';
};

export type GetGithubConfigurationResponses = {
  /**
   * OK
   */
  200: GithubConfigurationResource;
};

export type GetGithubConfigurationResponse =
  GetGithubConfigurationResponses[keyof GetGithubConfigurationResponses];

export type UpdateGithubConfigurationData = {
  body: GithubConfigurationUpdateRestRequest;
  path: {
    id: string;
  };
  query?: never;
  url: '/v2/dop-translation/github-configurations/{id}';
};

export type UpdateGithubConfigurationResponses = {
  /**
   * OK
   */
  200: GithubConfigurationResource;
};

export type UpdateGithubConfigurationResponse =
  UpdateGithubConfigurationResponses[keyof UpdateGithubConfigurationResponses];

export type GetModeData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/clean-code-policy/mode';
};

export type GetModeResponses = {
  /**
   * OK
   */
  200: ModeResource;
};

export type GetModeResponse = GetModeResponses[keyof GetModeResponses];

export type PatchModeData = {
  body: ModeResourceWritable;
  path?: never;
  query?: never;
  url: '/v2/clean-code-policy/mode';
};

export type PatchModeResponses = {
  /**
   * OK
   */
  200: ModeResource;
};

export type PatchModeResponse = PatchModeResponses[keyof PatchModeResponses];

export type DeleteGroupData = {
  body?: never;
  path: {
    /**
     * The ID of the group to delete.
     */
    id: string;
  };
  query?: never;
  url: '/v2/authorizations/groups/{id}';
};

export type DeleteGroupResponses = {
  /**
   * No Content
   */
  204: void;
};

export type DeleteGroupResponse =
  DeleteGroupResponses[keyof DeleteGroupResponses];

export type FetchGroupData = {
  body?: never;
  path: {
    /**
     * The id of the group to fetch.
     */
    id: string;
  };
  query?: never;
  url: '/v2/authorizations/groups/{id}';
};

export type FetchGroupResponses = {
  /**
   * OK
   */
  200: GroupRestResponse;
};

export type FetchGroupResponse = FetchGroupResponses[keyof FetchGroupResponses];

export type UpdateGroupData = {
  body: GroupUpdateRestRequest;
  path: {
    id: string;
  };
  query?: never;
  url: '/v2/authorizations/groups/{id}';
};

export type UpdateGroupResponses = {
  /**
   * OK
   */
  200: GroupRestResponse;
};

export type UpdateGroupResponse =
  UpdateGroupResponses[keyof UpdateGroupResponses];

export type GetStatusData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/system/migrations-status';
};

export type GetStatusResponses = {
  /**
   * OK
   */
  200: DatabaseMigrationsResponse;
};

export type GetStatusResponse = GetStatusResponses[keyof GetStatusResponses];

export type LivenessCheckData = {
  body?: never;
  headers?: {
    /**
     * Passcode can be provided, see SonarQube documentation
     */
    'X-Sonar-Passcode'?: string;
  };
  path?: never;
  query?: never;
  url: '/v2/system/liveness';
};

export type LivenessCheckErrors = {
  /**
   * This SonarQube node is not alive and should be rescheduled
   */
  default: unknown;
};

export type LivenessCheckResponses = {
  /**
   * This SonarQube node is alive
   */
  204: void;
};

export type LivenessCheckResponse =
  LivenessCheckResponses[keyof LivenessCheckResponses];

export type GetHealthData = {
  body?: never;
  headers?: {
    'X-Sonar-Passcode'?: string;
  };
  path?: never;
  query?: never;
  url: '/v2/system/health';
};

export type GetHealthResponses = {
  /**
   * OK
   */
  200: Health;
};

export type GetHealthResponse = GetHealthResponses[keyof GetHealthResponses];

export type GenerateReportData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Key of the project to build report for
     */
    projectKey: string;
    /**
     * Key of the branch to build report for
     */
    branchKey?: string;
    /**
     * Type of report to generate.
     * The `Accept` header sent by the client determines the format of the report.
     * Currently supported: cyclonedx (application/vnd.cyclonedx+json), cyclonedx (application/vnd.cyclonedx+xml),
     * spdx (application/vnd.spdx+json), spdx (application/vnd.spdx+xml)
     *
     */
    type: 'cyclonedx' | 'spdx_23';
  };
  url: '/v2/sca/sbom-reports';
};

export type GenerateReportResponses = {
  /**
   * The desired report in the desired output format
   */
  200: string;
};

export type GenerateReportResponse =
  GenerateReportResponses[keyof GenerateReportResponses];

export type Search3Data = {
  body?: never;
  path?: never;
  query: {
    /**
     * Key of the project to fetch all dependencies from
     */
    projectKey: string;
    /**
     * Key of the Branch to fetch all dependencies from. If not provided, the default branch will be used unless a Pull Request Key is provided.
     */
    branchKey?: string;
    /**
     * Key of the Pull Request to fetch all dependencies from.
     */
    pullRequestKey?: string;
    /**
     * Filter on the direct attribute. TRUE stands for direct dependencies, FALSE for transitive dependencies.
     */
    direct?: boolean;
    /**
     * Filter on the newInPullRequest attribute. TRUE stands for only releases introduced vs. the target branch, FALSE for releases shared with target.
     */
    newInPullRequest?: boolean;
    /**
     * Filter on the productionScope attribute. TRUE stands for only production dependencies, FALSE for only not in production. If a release is both, it matches both.
     */
    productionScope?: boolean;
    /**
     * Filter on the package manager
     */
    packageManagers?: Array<string>;
    /**
     * Filter on the package name. This parameter performs a partial match (contains and case insensitive) on the package name.
     */
    q?: string;
    /**
     * Number of results per page. A value of 0 will only return the pagination information.
     */
    pageSize?: number;
    /**
     * 1-based page index
     */
    pageIndex?: number;
  };
  url: '/v2/sca/releases';
};

export type Search3Responses = {
  /**
   * OK
   */
  200: ReleasesSearchRestResponse;
};

export type Search3Response = Search3Responses[keyof Search3Responses];

export type FetchReleaseData = {
  body?: never;
  path: {
    /**
     * The key of the release to fetch.
     */
    key: string;
  };
  query?: never;
  url: '/v2/sca/releases/{key}';
};

export type FetchReleaseResponses = {
  /**
   * OK
   */
  200: ReleaseDetailResource;
};

export type FetchReleaseResponse =
  FetchReleaseResponses[keyof FetchReleaseResponses];

export type Search4Data = {
  body?: never;
  path?: never;
  query: {
    /**
     * Key of the project to fetch all dependency risks from
     */
    projectKey: string;
    /**
     * Key of the branch to fetch all dependency risks from. If not provided, the default branch will be used unless a Pull Request Key is provided.
     */
    branchKey?: string;
    /**
     * Key of the Pull Request to fetch all dependency risks from.
     */
    pullRequestKey?: string;
    /**
     * Filter on the package manager
     */
    packageManagers?: Array<string>;
    /**
     * Filter on the issue type
     */
    types?: Array<string>;
    /**
     * Filter on the severity
     */
    severities?: Array<string>;
    /**
     * Filter on the package name This parameter performs a partial match (contains and case insensitive) on the package name.
     */
    packageName?: string;
    /**
     * Filter on the vulnerability IDThis parameter performs a partial match (contains and case insensitive) on the vulnerability ID.
     */
    vulnerabilityId?: string;
    /**
     * Filter on the newInPullRequest attribute. TRUE stands for only releases introduced vs. the target branch, FALSE for releases shared with target.
     */
    newInPullRequest?: boolean;
    /**
     * Filter on the direct attribute. TRUE stands for only direct dependencies, FALSE for only transitive. If a release is both, it matches both.
     */
    direct?: boolean;
    /**
     * Filter on the productionScope attribute. TRUE stands for only production dependencies, FALSE for only not in production. If a release is both, it matches both.
     */
    productionScope?: boolean;
    /**
     * Sort order
     */
    sort?:
      | '+identity'
      | '-identity'
      | '+severity'
      | '-severity'
      | '+cvssScore'
      | '-cvssScore';
    /**
     * Number of results per page. A value of 0 will only return the pagination information.
     */
    pageSize?: number;
    /**
     * 1-based page index
     */
    pageIndex?: number;
  };
  url: '/v2/sca/issues-releases';
};

export type Search4Responses = {
  /**
   * OK
   */
  200: DependencyRisksSearchRestResponse;
};

export type Search4Response = Search4Responses[keyof Search4Responses];

export type FetchDependencyRiskData = {
  body?: never;
  path: {
    /**
     * The key of the issue,release pair to fetch.
     */
    key: string;
  };
  query?: never;
  url: '/v2/sca/issues-releases/{key}';
};

export type FetchDependencyRiskResponses = {
  /**
   * OK
   */
  200: DependencyRiskDetailsResource;
};

export type FetchDependencyRiskResponse =
  FetchDependencyRiskResponses[keyof FetchDependencyRiskResponses];

export type GetScaClisMetadataData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Filter by operating system
     */
    os?: 'windows' | 'linux' | 'macos';
    /**
     * Filter by CPU architecture
     */
    arch?: 'x64' | 'aarch64';
  };
  url: '/v2/sca/clis';
};

export type GetScaClisMetadataResponses = {
  /**
   * OK
   */
  200: Array<ScaCliInfoRestResponse>;
};

export type GetScaClisMetadataResponse =
  GetScaClisMetadataResponses[keyof GetScaClisMetadataResponses];

export type DownloadScaCliData = {
  body?: never;
  path: {
    /**
     * The ID of the SCA CLI download
     */
    id: string;
  };
  query?: never;
  url: '/v2/sca/clis/{id}';
};

export type DownloadScaCliResponses = {
  /**
   * OK
   */
  200: ScaCliInfoRestResponse | Blob | File;
};

export type DownloadScaCliResponse =
  DownloadScaCliResponses[keyof DownloadScaCliResponses];

export type GetLlmProvidersData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/fix-suggestions/supported-llm-providers';
};

export type GetLlmProvidersResponses = {
  /**
   * OK
   */
  200: Array<LlmProviderResponseDto>;
};

export type GetLlmProvidersResponse =
  GetLlmProvidersResponses[keyof GetLlmProvidersResponses];

export type GetData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/fix-suggestions/service-info';
};

export type GetResponses = {
  /**
   * OK
   */
  200: ServiceInfo;
};

export type GetResponse = GetResponses[keyof GetResponses];

export type GetSubscriptionTypeData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/fix-suggestions/service-info/subscription-type';
};

export type GetSubscriptionTypeResponses = {
  /**
   * OK
   */
  200: SubscriptionTypeResponse;
};

export type GetSubscriptionTypeResponse =
  GetSubscriptionTypeResponses[keyof GetSubscriptionTypeResponses];

export type Get1Data = {
  body?: never;
  path: {
    issueId: string;
  };
  query?: never;
  url: '/v2/fix-suggestions/issues/{issueId}';
};

export type Get1Responses = {
  /**
   * OK
   */
  200: FixSuggestionIssueResponse;
};

export type Get1Response = Get1Responses[keyof Get1Responses];

export type GetProjectBindingByProjectIdData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Filter on the repository name.
     * This parameter performs an exact, case insensitive, match.
     *
     */
    repository?: string;
    /**
     * Filter on the DevOps Platform setting id.
     */
    dopSettingId?: string;
    /**
     * Number of results per page. A value of 0 will only return the pagination information.
     */
    pageSize?: number;
    /**
     * 1-based page index
     */
    pageIndex?: number;
  };
  url: '/v2/dop-translation/project-bindings';
};

export type GetProjectBindingByProjectIdResponses = {
  /**
   * OK
   */
  200: ProjectBindingsSearchRestResponse;
};

export type GetProjectBindingByProjectIdResponse =
  GetProjectBindingByProjectIdResponses[keyof GetProjectBindingByProjectIdResponses];

export type GetProjectBindingData = {
  body?: never;
  path: {
    /**
     * The id of the project-bindings to fetch.
     */
    id: string;
  };
  query?: never;
  url: '/v2/dop-translation/project-bindings/{id}';
};

export type GetProjectBindingResponses = {
  /**
   * OK
   */
  200: ProjectBinding;
};

export type GetProjectBindingResponse =
  GetProjectBindingResponses[keyof GetProjectBindingResponses];

export type FetchAllDopSettingsData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/dop-translation/dop-settings';
};

export type FetchAllDopSettingsResponses = {
  /**
   * OK
   */
  200: DopSettingsRestResponse;
};

export type FetchAllDopSettingsResponse =
  FetchAllDopSettingsResponses[keyof FetchAllDopSettingsResponses];

export type 踼Data = {
  body?: never;
  path?: never;
  query: {
    /**
     * The key of the project.
     */
    projectKey: string;
    /**
     * The key of the branch.
     */
    branchKey: string;
    /**
     * The source that produced this graph. eg. java, python, js, etc.
     */
    source: string;
  };
  url: '/v2/architecture/file-graph';
};

export type 踼Responses = {
  /**
   * OK
   */
  200: string;
};

export type 踼Response = 踼Responses[keyof 踼Responses];

export type GetVersionData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/analysis/version';
};

export type GetVersionResponses = {
  /**
   * OK
   */
  200: string;
};

export type GetVersionResponse = GetVersionResponses[keyof GetVersionResponses];

export type GetJresMetadataData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Filter the JRE by operating system. Accepted values are 'windows', 'linux', 'macos', 'alpine' (case-insensitive), with some aliases
     */
    os?: string;
    /**
     * Filter the JRE by CPU architecture. Accepted values are 'x64' and 'aarch64' (case-insensitive), with some aliases.
     */
    arch?: string;
  };
  url: '/v2/analysis/jres';
};

export type GetJresMetadataResponses = {
  /**
   * OK
   */
  200: Array<JreInfoRestResponse>;
};

export type GetJresMetadataResponse =
  GetJresMetadataResponses[keyof GetJresMetadataResponses];

export type DownloadJreData = {
  body?: never;
  path: {
    /**
     * The ID of the JRE
     */
    id: string;
  };
  query?: never;
  url: '/v2/analysis/jres/{id}';
};

export type DownloadJreResponses = {
  /**
   * OK
   */
  200: JreInfoRestResponse | Blob | File;
};

export type DownloadJreResponse =
  DownloadJreResponses[keyof DownloadJreResponses];

export type DownloadScannerEngineData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/analysis/engine';
};

export type DownloadScannerEngineResponses = {
  /**
   * OK
   */
  200: EngineInfoRestResponse | Blob | File;
};

export type DownloadScannerEngineResponse =
  DownloadScannerEngineResponses[keyof DownloadScannerEngineResponses];

export type GetActiveRulesData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Project Key
     */
    projectKey: string;
  };
  url: '/v2/analysis/active_rules';
};

export type GetActiveRulesResponses = {
  /**
   * OK
   */
  200: Array<ActiveRule>;
};

export type GetActiveRulesResponse =
  GetActiveRulesResponses[keyof GetActiveRulesResponses];

export type DeleteData = {
  body?: never;
  path: {
    /**
     * The ID of the group membership to delete.
     */
    id: string;
  };
  query?: never;
  url: '/v2/authorizations/group-memberships/{id}';
};

export type DeleteResponses = {
  /**
   * No Content
   */
  204: void;
};

export type DeleteResponse = DeleteResponses[keyof DeleteResponses];

export type SearchIssuesData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Page size. Must be greater than 0 and less or equal than 500
     */
    ps?: bigint;
    /**
     * Current page
     */
    p?: number;
    /**
     * Comma-separated list of component keys. Retrieve issues associated with the specified components and their descendants.
     */
    componentKeys?: string;
    /**
     * Comma-separated list of project keys. Retrieve issues associated with the specified projects.
     */
    projectKeys?: string;
    /**
     * Comma-separated list of severities (INFO, MINOR, MAJOR, CRITICAL, BLOCKER).
     */
    severities?: string;
    /**
     * Comma-separated list of assignee logins. The value '__me__' can be used as a placeholder for user who performs the request
     */
    assignees?: string;
    /**
     * Comma-separated list of issue types (CODE_SMELL, BUG, VULNERABILITY).
     */
    types?: string;
    /**
     * Comma-separated list of statuses (OPEN, CONFIRMED, REOPENED, RESOLVED, CLOSED).
     */
    statuses?: string;
    /**
     * Comma-separated list of resolutions (FALSE-POSITIVE, WONTFIX, FIXED, REMOVED).
     */
    resolutions?: string;
    /**
     * Sort field
     */
    s?:
      | 'HOTSPOTS'
      | 'FILE_LINE'
      | 'STATUS'
      | 'SEVERITY'
      | 'CLOSE_DATE'
      | 'CREATION_DATE'
      | 'UPDATE_DATE';
    /**
     * Ascending sort. Default is false (descending).
     */
    asc?: boolean;
    /**
     * To match resolved or unresolved issues
     */
    resolved?: boolean;
    /**
     * Comma-separated list of rule keys.
     */
    rules?: string;
    /**
     * Comma-separated list of tags.
     */
    tags?: string;
    /**
     * Comma-separated list of SCM accounts. To set several values, the parameter must be called once for each value.
     */
    authors?: string;
    /**
     * Filter issues created after the given date (format YYYY-MM-DD or datetime ISO format).
     */
    createdAfter?: Date;
    /**
     * Filter issues created before the given date (format YYYY-MM-DD or datetime ISO format).
     */
    createdBefore?: Date;
    /**
     * Filter issues created at a specific date (format YYYY-MM-DD or datetime ISO format).
     */
    createdAt?: Date;
    /**
     * Filter issues created during a time span before now (e.g. 1m, 1h, 1d, 1w, 1y).
     */
    createdInLast?: string;
    /**
     * Comma-separated list of language keys.
     */
    languages?: string;
    /**
     * Comma-separated list of facets to include in the response.
     */
    facets?: string;
    /**
     * Comma-separated list of the optional fields to be returned in response. Action plans are dropped in 5.5, it is not returned in the response.
     */
    additionalFields?: string;
  };
  url: '/issues/search';
};

export type SearchIssuesErrors = {
  /**
   * The server could not understand the request due to invalid syntax. The client should modify the request and try again.
   */
  400: {
    errors?: Array<{
      message: string;
    }>;
    message: string;
  };
  /**
   * Authentication is required to access the requested resource. The client must include the appropriate credentials.
   */
  401: {
    message: string;
  };
  /**
   * Forbidden - The user does not have the required permissions
   */
  403: unknown;
  /**
   * Not found - The requested resource does not exist
   */
  404: unknown;
  /**
   * Internal server error
   */
  500: unknown;
  /**
   * The server is currently unable to handle the request due to a temporary overload or scheduled maintenance. Try again later.
   */
  503: {
    message: string;
    retryAfter?: number;
  };
};

export type SearchIssuesError = SearchIssuesErrors[keyof SearchIssuesErrors];

export type SearchIssuesResponses = {
  /**
   * The request was successful, and the server has returned the requested resource in the response body.
   */
  200: IssueSearchResponse;
};

export type SearchIssuesResponse =
  SearchIssuesResponses[keyof SearchIssuesResponses];

export type SearchProjectsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Filter the projects for which the last analysis of all branches are older than the given date (exclusive).
     * Either a date (server timezone) or datetime can be provided.
     */
    analyzedBefore?: string;
    /**
     * 1-based page number
     */
    p?: number;
    /**
     * Limit search to:
     * component names that contain the supplied string
     * component keys that contain the supplied string
     */
    q?: string;
    /**
     * Filter the projects that are provisioned
     */
    onProvisionedOnly?: boolean;
    /**
     * Comma-separated list of project keys
     */
    projects?: string;
    /**
     * Page size. Must be greater than 0 and less or equal than 500
     */
    ps?: number;
    /**
     * Comma-separated list of component qualifiers. Filter the results with the specified qualifiers
     */
    qualifiers?: string;
  };
  url: '/projects/search';
};

export type SearchProjectsErrors = {
  /**
   * Authentication is required to access the requested resource. The client must include the appropriate credentials.
   */
  401: {
    message: string;
  };
};

export type SearchProjectsError =
  SearchProjectsErrors[keyof SearchProjectsErrors];

export type SearchProjectsResponses = {
  /**
   * The request was successful, and the server has returned the requested resource in the response body.
   */
  200: ProjectSearchResponse;
};

export type SearchProjectsResponse =
  SearchProjectsResponses[keyof SearchProjectsResponses];

export type ComponentData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Comma-separated list of additional fields that can be returned in the response.
     */
    additionalFields?: 'metrics' | 'period';
    /**
     * Branch key. Not available in the community edition.
     */
    branch?: string;
    /**
     * Component key
     */
    component: string;
    /**
     * Comma-separated list of metric keys
     */
    metricKeys:
      | 'accepted_issues'
      | 'new_software_quality_maintainability_remediation_effort'
      | 'new_technical_debt'
      | 'high_impact_accepted_issues'
      | 'blocker_violations'
      | 'software_quality_blocker_issues'
      | 'bugs'
      | 'classes'
      | 'code_smells'
      | 'cognitive_complexity'
      | 'comment_lines'
      | 'comment_lines_density'
      | 'branch_coverage'
      | 'new_branch_coverage'
      | 'conditions_to_cover'
      | 'new_conditions_to_cover'
      | 'confirmed_issues'
      | 'coverage'
      | 'new_coverage'
      | 'critical_violations'
      | 'complexity'
      | 'duplicated_blocks'
      | 'new_duplicated_blocks'
      | 'duplicated_files'
      | 'duplicated_lines'
      | 'duplicated_lines_density'
      | 'new_duplicated_lines_density'
      | 'new_duplicated_lines'
      | 'effort_to_reach_software_quality_maintainability_rating_a'
      | 'effort_to_reach_maintainability_rating_a'
      | 'false_positive_issues'
      | 'files'
      | 'functions'
      | 'generated_lines'
      | 'generated_ncloc'
      | 'software_quality_high_issues'
      | 'info_violations'
      | 'software_quality_info_issues'
      | 'violations'
      | 'prioritized_rule_issues'
      | 'line_coverage'
      | 'new_line_coverage'
      | 'lines'
      | 'ncloc'
      | 'lines_to_cover'
      | 'new_lines_to_cover'
      | 'software_quality_low_issues'
      | 'software_quality_maintainability_issues'
      | 'sqale_rating'
      | 'software_quality_maintainability_rating'
      | 'new_maintainability_rating'
      | 'new_software_quality_maintainability_rating'
      | 'major_violations'
      | 'software_quality_medium_issues'
      | 'minor_violations'
      | 'new_accepted_issues'
      | 'new_blocker_violations'
      | 'new_software_quality_blocker_issues'
      | 'new_bugs'
      | 'new_code_smells'
      | 'new_critical_violations'
      | 'new_software_quality_high_issues'
      | 'new_info_violations'
      | 'new_software_quality_info_issues'
      | 'new_violations'
      | 'new_lines'
      | 'new_software_quality_low_issues'
      | 'new_software_quality_maintainability_issues'
      | 'new_major_violations'
      | 'new_software_quality_medium_issues'
      | 'new_minor_violations'
      | 'new_software_quality_reliability_issues'
      | 'new_security_hotspots'
      | 'new_software_quality_security_issues'
      | 'new_vulnerabilities'
      | 'open_issues'
      | 'projects'
      | 'alert_status'
      | 'releasability_rating'
      | 'software_quality_reliability_issues'
      | 'reliability_rating'
      | 'software_quality_reliability_rating'
      | 'new_software_quality_reliability_rating'
      | 'new_reliability_rating'
      | 'software_quality_reliability_remediation_effort'
      | 'reliability_remediation_effort'
      | 'new_reliability_remediation_effort'
      | 'new_software_quality_reliability_remediation_effort'
      | 'reopened_issues'
      | 'security_hotspots'
      | 'security_hotspots_reviewed'
      | 'new_security_hotspots_reviewed'
      | 'software_quality_security_issues'
      | 'security_rating'
      | 'software_quality_security_rating'
      | 'new_software_quality_security_rating'
      | 'new_security_rating'
      | 'security_remediation_effort'
      | 'software_quality_security_remediation_effort'
      | 'new_software_quality_security_remediation_effort'
      | 'new_security_remediation_effort'
      | 'security_review_rating'
      | 'new_security_review_rating'
      | 'skipped_tests'
      | 'statements'
      | 'sqale_index'
      | 'software_quality_maintainability_remediation_effort'
      | 'sqale_debt_ratio'
      | 'software_quality_maintainability_debt_ratio'
      | 'new_software_quality_maintainability_debt_ratio'
      | 'new_sqale_debt_ratio'
      | 'uncovered_conditions'
      | 'new_uncovered_conditions'
      | 'uncovered_lines'
      | 'new_uncovered_lines'
      | 'test_execution_time'
      | 'test_errors'
      | 'test_failures'
      | 'tests'
      | 'test_success_density'
      | 'vulnerabilities';
    /**
     * Pull request id. Not available in the community edition.
     */
    pullRequest: string;
  };
  url: '/measures/component';
};

export type ComponentErrors = {
  /**
   * Authentication is required to access the requested resource. The client must include the appropriate credentials.
   */
  401: {
    message: string;
  };
  /**
   * The server understood the request, but refuses to authorize it. Ensure the client has appropriate permissions.
   */
  403: {
    message: string;
  };
};

export type ComponentError = ComponentErrors[keyof ComponentErrors];

export type ComponentResponses = {
  /**
   * The request was successful, and the server has returned the requested resource in the response body.
   */
  200: MeasureComponentResponse;
};

export type ComponentResponse = ComponentResponses[keyof ComponentResponses];

export type AddPermissionToAuserData = {
  body?: never;
  path?: never;
  query: {
    /**
     * User login
     */
    login: string;
    /**
     * The permission you would like to grant to the user
     *
     * Possible values for global permissions: admin, gateadmin, profileadmin, provisioning, scan, applicationcreator, portfoliocreator
     *
     * Possible values for project permissions admin, codeviewer, issueadmin, securityhotspotadmin, scan, user
     */
    permission: string;
    /**
     * Project id
     */
    projectId?: string;
    /**
     * Project key
     */
    projectKey?: string;
  };
  url: '/permissions/add_user';
};

export type AddPermissionToAuserResponses = {
  /**
   * The request was successful, and the server has returned the requested resource in the response body.
   */
  200: {
    data: {
      [key: string]: unknown;
    };
  };
};

export type AddPermissionToAuserResponse =
  AddPermissionToAuserResponses[keyof AddPermissionToAuserResponses];

export type AddAPermissionToAGroupData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Group name or 'anyone' (case insensitive)
     */
    groupName: string;
    /**
     * The permission you would like to grant to the group.
     *
     * Possible values for global permissions: admin, gateadmin, profileadmin, provisioning, scan, applicationcreator, portfoliocreator
     *
     * Possible values for project permissions admin, codeviewer, issueadmin, securityhotspotadmin, scan, user
     */
    permission: string;
    /**
     * Project id
     */
    projectId?: string;
    /**
     * Project key
     */
    projectKey?: string;
  };
  url: '/permissions/add_group';
};

export type AddAPermissionToAGroupResponses = {
  /**
   * The request was successful, and the server has returned the requested resource in the response body.
   */
  200: {
    data: {
      [key: string]: unknown;
    };
  };
};

export type AddAPermissionToAGroupResponse =
  AddAPermissionToAGroupResponses[keyof AddAPermissionToAGroupResponses];

export type RemovePermissionFromAuserData = {
  body?: never;
  path?: never;
  query: {
    /**
     * User login
     */
    login: string;
    /**
     * The permission you would like to revoke from the user.
     *
     * Possible values for global permissions: admin, gateadmin, profileadmin, provisioning, scan, applicationcreator, portfoliocreator
     *
     * Possible values for project permissions admin, codeviewer, issueadmin, securityhotspotadmin, scan, user
     */
    permission: string;
    /**
     * Project id
     */
    projectId?: string;
    /**
     * Project key
     */
    projectKey?: string;
  };
  url: '/permissions/remove_user';
};

export type RemovePermissionFromAuserResponses = {
  /**
   * The request was successful, and the server has returned the requested resource in the response body.
   */
  200: {
    data: {
      [key: string]: unknown;
    };
  };
};

export type RemovePermissionFromAuserResponse =
  RemovePermissionFromAuserResponses[keyof RemovePermissionFromAuserResponses];

export type RemoveAPermissionFromAGroupData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Group name or 'anyone' (case insensitive)
     */
    groupName: string;
    /**
     * The permission you would like to revoke from the group.
     *
     * Possible values for global permissions: admin, gateadmin, profileadmin, provisioning, scan, applicationcreator, portfoliocreator
     *
     * Possible values for project permissions admin, codeviewer, issueadmin, securityhotspotadmin, scan, user
     */
    permission: string;
    /**
     * Project id
     */
    projectId?: string;
    /**
     * Project key
     */
    projectKey?: string;
  };
  url: '/permissions/remove_group';
};

export type RemoveAPermissionFromAGroupResponses = {
  /**
   * The request was successful, and the server has returned the requested resource in the response body.
   */
  200: {
    data: {
      [key: string]: unknown;
    };
  };
};

export type RemoveAPermissionFromAGroupResponse =
  RemoveAPermissionFromAGroupResponses[keyof RemoveAPermissionFromAGroupResponses];

export type GetAListOfProjectsAndLicenseUsageData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/projects/license_usage';
};

export type GetAListOfProjectsAndLicenseUsageErrors = {
  /**
   * Authentication is required to access the requested resource. The client must include the appropriate credentials.
   */
  401: {
    message: string;
  };
  /**
   * The server understood the request, but refuses to authorize it. Ensure the client has appropriate permissions.
   */
  403: {
    message: string;
  };
  /**
   * The server encountered an unexpected condition that prevented it from fulfilling the request. Report the issue to the support team if it persists.
   */
  500: {
    message: string;
  };
};

export type GetAListOfProjectsAndLicenseUsageError =
  GetAListOfProjectsAndLicenseUsageErrors[keyof GetAListOfProjectsAndLicenseUsageErrors];

export type GetAListOfProjectsAndLicenseUsageResponses = {
  /**
   * The request was successful, and the server has returned the requested resource in the response body.
   */
  200: {
    projects: Array<{
      projectKey: string;
      projectName: string;
      branch: string;
      licenseUsagePercentage: number;
      linesOfCode: number;
    }>;
  };
};

export type GetAListOfProjectsAndLicenseUsageResponse =
  GetAListOfProjectsAndLicenseUsageResponses[keyof GetAListOfProjectsAndLicenseUsageResponses];

export type SearchUserTokensData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * User login (admin credentials required to list tokens of another user)
     */
    login?: string;
  };
  url: '/user_tokens/search';
};

export type SearchUserTokensErrors = {
  /**
   * Authentication is required to access the requested resource. The client must include the appropriate credentials.
   */
  401: {
    message: string;
  };
  /**
   * The server understood the request, but refuses to authorize it. Ensure the client has appropriate permissions.
   */
  403: {
    message: string;
  };
};

export type SearchUserTokensError =
  SearchUserTokensErrors[keyof SearchUserTokensErrors];

export type SearchUserTokensResponses = {
  /**
   * The request was successful, and the server has returned the requested resource in the response body.
   */
  200: UserTokenSearchResponse;
};

export type SearchUserTokensResponse =
  SearchUserTokensResponses[keyof SearchUserTokensResponses];

export type GenerateUserTokenData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Token name
     */
    name: string;
    /**
     * User login (admin credentials required to generate token for another user)
     */
    login?: string;
    /**
     * Token type
     */
    type?: 'USER_TOKEN' | 'GLOBAL_ANALYSIS_TOKEN' | 'PROJECT_ANALYSIS_TOKEN';
    /**
     * Project key (required for PROJECT_ANALYSIS_TOKEN type)
     */
    projectKey?: string;
    /**
     * Token expiration date (format YYYY-MM-DD)
     */
    expirationDate?: Date;
  };
  url: '/user_tokens/generate';
};

export type GenerateUserTokenErrors = {
  /**
   * The server could not understand the request due to invalid syntax. The client should modify the request and try again.
   */
  400: {
    errors?: Array<{
      message: string;
    }>;
    message: string;
  };
  /**
   * Authentication is required to access the requested resource. The client must include the appropriate credentials.
   */
  401: {
    message: string;
  };
  /**
   * The server understood the request, but refuses to authorize it. Ensure the client has appropriate permissions.
   */
  403: {
    message: string;
  };
};

export type GenerateUserTokenError =
  GenerateUserTokenErrors[keyof GenerateUserTokenErrors];

export type GenerateUserTokenResponses = {
  /**
   * The request was successful, and the server has returned the requested resource in the response body.
   */
  200: UserTokenGenerateResponse;
};

export type GenerateUserTokenResponse =
  GenerateUserTokenResponses[keyof GenerateUserTokenResponses];

export type RevokeUserTokenData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Token name
     */
    name: string;
    /**
     * User login (admin credentials required to revoke token of another user)
     */
    login?: string;
  };
  url: '/user_tokens/revoke';
};

export type RevokeUserTokenErrors = {
  /**
   * The server could not understand the request due to invalid syntax. The client should modify the request and try again.
   */
  400: {
    errors?: Array<{
      message: string;
    }>;
    message: string;
  };
  /**
   * Authentication is required to access the requested resource. The client must include the appropriate credentials.
   */
  401: {
    message: string;
  };
  /**
   * The server understood the request, but refuses to authorize it. Ensure the client has appropriate permissions.
   */
  403: {
    message: string;
  };
  /**
   * Not found - The token does not exist
   */
  404: unknown;
};

export type RevokeUserTokenError =
  RevokeUserTokenErrors[keyof RevokeUserTokenErrors];

export type RevokeUserTokenResponses = {
  /**
   * No content - Token successfully revoked
   */
  204: void;
};

export type RevokeUserTokenResponse =
  RevokeUserTokenResponses[keyof RevokeUserTokenResponses];

export type ClientOptions = {
  baseUrl: 'http://sonarqube.internal.philips/api/v2' | (string & {});
};
