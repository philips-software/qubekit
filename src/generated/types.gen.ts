// This file is auto-generated by @hey-api/openapi-ts

export type UserCreateRestRequest = {
  /**
   * User email
   */
  email?: string;
  /**
   * Specify if the user should be authenticated from SonarQube server or from an external authentication system. Password should not be set when local is set to false.
   */
  local?: boolean;
  /**
   * User login
   */
  login: string;
  /**
   * User name
   */
  name: string;
  /**
   * List of SCM accounts.
   */
  scmAccounts?: Array<string>;
};

export type UserRestResponseForAdmins = {
  readonly id?: string;
  login?: string;
  name?: string;
  email?: string;
  readonly active?: boolean;
  readonly local?: boolean;
  readonly managed?: boolean;
  externalLogin?: string;
  externalProvider?: string;
  externalId?: string;
  avatar?: string;
  readonly sonarQubeLastConnectionDate?: string;
  readonly sonarLintLastConnectionDate?: string;
  scmAccounts?: Array<string>;
};

export type EmailConfigurationCreateRestRequest = {
  /**
   * URL of your SMTP server
   */
  host: string;
  /**
   * Port of your SMTP server (usually 25, 587 or 465)
   */
  port: string;
  /**
   * Security protocol used to connect to your SMTP server (SSLTLS is recommended)
   */
  securityProtocol: 'NONE' | 'SSLTLS' | 'STARTTLS';
  /**
   * Address emails will come from
   */
  fromAddress: string;
  /**
   * Name emails will come from (usually "SonarQube")
   */
  fromName: string;
  /**
   * Prefix added to email so they can be easily recognized (usually "[SonarQube]")
   */
  subjectPrefix: string;
  /**
   * Authentication method used to connect to the SMTP server. OAuth is only supported for Microsoft Exchange
   */
  authMethod: 'BASIC' | 'OAUTH';
  /**
   * For Basic and OAuth authentication: username used to authenticate to the SMTP server
   */
  username: string;
  /**
   * For OAuth authentication: host of the Identity Provider issuing access tokens
   */
  oauthAuthenticationHost?: string;
  /**
   * For OAuth authentication: Microsoft tenant
   */
  oauthTenant?: string;
};

export type EmailConfigurationResource = {
  readonly id?: string;
  /**
   * URL of your SMTP server
   */
  host?: string;
  /**
   * Port of your SMTP server (usually 25, 587 or 465)
   */
  port?: string;
  /**
   * Security protocol used to connect to your SMTP server (SSLTLS is recommended)
   */
  securityProtocol?: 'NONE' | 'SSLTLS' | 'STARTTLS';
  /**
   * Address emails will come from
   */
  fromAddress?: string;
  /**
   * Name emails will come from (usually "SonarQube")
   */
  fromName?: string;
  /**
   * Prefix added to email so they can be easily recognized (usually "[SonarQube]")
   */
  subjectPrefix?: string;
  /**
   * Authentication method used to connect to the SMTP server. OAuth is only supported for Microsoft Exchange
   */
  authMethod?: 'BASIC' | 'OAUTH';
  /**
   * For Basic and OAuth authentication: username used to authenticate to the SMTP server
   */
  username?: string;
  /**
   * For Basic authentication: has the password field been set?
   */
  isBasicPasswordSet?: boolean;
  /**
   * For OAuth authentication: host of the Identity Provider issuing access tokens
   */
  oauthAuthenticationHost?: string;
  /**
   * For OAuth authentication: has the Client ID field been set?
   */
  isOauthClientIdSet?: boolean;
  /**
   * For OAuth authentication: has the Client secret field been set?
   */
  isOauthClientSecretSet?: boolean;
  /**
   * For OAuth authentication: Microsoft tenant
   */
  oauthTenant?: string;
};

export type LicenseProfilesCreateRestRequest = {
  /**
   * The name of the license policy
   */
  name: string;
  /**
   * Whether this license policy is the default or not
   */
  default?: boolean;
};

export type LicenseProfileResource = {
  id?: string;
  key?: string;
  name?: string;
  default?: boolean;
  actions?: LicenseProfileSingleActions;
  updatedAt?: string;
};

export type LicenseProfileSingleActions = {
  edit?: boolean;
  setAsDefault?: boolean;
  associateProjects?: boolean;
  delete?: boolean;
};

export type UpdateAssigneeRestRequest = {
  /**
   * Issue release key
   */
  issueReleaseKey: string;
  /**
   * Assignee login
   */
  assigneeLogin?: string;
};

export type AffectedPackageResource = {
  purl?: string;
  /**
   * The maintainer's overall recommendation, if available
   */
  recommendation?: 'ignore' | 'upgrade' | 'upgrade_or_workaround';
  recommendationDetails?: VulnerabilityRecommendationDetailsResource;
  versionOptions?: Array<VersionOptionResource>;
  affectedVersions?: Array<string>;
  unaffectedVersions?: string;
};

export type IssueReleaseBranchResource = {
  uuid?: string;
  key?: string;
  isPullRequest?: boolean;
  projectKey?: string;
  projectName?: string;
  legacyProjectUuid?: string;
  organizationUuid?: string;
};

export type IssueReleaseDetailsResource = {
  key?: string;
  severity?: string;
  originalSeverity?: string;
  manualSeverity?: string;
  showIncreasedSeverityWarning?: boolean;
  release?: ReleaseSearchResource;
  type?: 'VULNERABILITY' | 'PROHIBITED_LICENSE';
  quality?: 'MAINTAINABILITY' | 'RELIABILITY' | 'SECURITY';
  status?: string;
  createdAt?: string;
  assignee?: UserResource;
  commentCount?: number;
  vulnerability?: VulnerabilityResource;
  spdxLicenseId?: string;
  transitions?: Array<'CONFIRM' | 'REOPEN' | 'SAFE' | 'FIXED' | 'ACCEPT'>;
  actions?: Array<'COMMENT' | 'ASSIGN' | 'SET_SEVERITY'>;
  branch?: IssueReleaseBranchResource;
};

export type ReleaseSearchResource = {
  key?: string;
  branchUuid?: string;
  packageUrl?: string;
  packageManager?: string;
  packageName?: string;
  version?: string;
  licenseExpression?: string;
  known?: boolean;
  knownPackage?: boolean;
  newlyIntroduced?: boolean;
  directSummary?: boolean;
  scopeSummary?: string;
  productionScopeSummary?: boolean;
  dependencyFilePaths?: Array<string>;
};

export type UserResource = {
  login?: string;
  name?: string;
  avatar?: string;
  active?: boolean;
};

export type VersionOptionResource = {
  /**
   * The version being presented as an option
   */
  version?: string;
  /**
   * Vulnerability IDs affecting this version
   */
  vulnerabilityIds?: Array<string>;
  /**
   * Is this version a pre-release version
   */
  prerelease?: boolean;
  /**
   * Describes which vulnerabilities are fixed
   */
  fixLevel?: 'COMPLETE' | 'PARTIAL' | 'NONE' | 'UNKNOWN';
  /**
   * How the frontend should label this version
   */
  descriptionCode?:
    | 'VERSION_IN_USE'
    | 'NEAREST_PARTIAL'
    | 'NEAREST_COMPLETE'
    | 'LATEST_PARTIAL'
    | 'LATEST_COMPLETE'
    | 'LATEST_STABLE'
    | 'LATEST_PRERELEASE'
    | 'UNKNOWN';
};

export type VulnerabilityRecommendationDetailsResource = {
  impactScore?: number;
  impactDescription?: string;
  realIssue?: boolean;
  falsePositiveReason?: string;
  includesDev?: boolean;
  specificMethodsAffected?: boolean;
  specificMethodsDescription?: string;
  otherConditions?: boolean;
  otherConditionsDescription?: string;
  workaroundAvailable?: boolean;
  workaroundDescription?: string;
  visibility?: string;
};

export type VulnerabilityReportResource = {
  id?: string;
  url?: string;
  type?: string;
  cvssScore?: string;
  cvssSeverity?: string;
  withdrawnAt?: string;
};

export type VulnerabilityResource = {
  vulnerabilityId?: string;
  reports?: Array<VulnerabilityReportResource>;
  description?: string;
  epssPercentile?: string;
  epssProbability?: string;
  knownExploited?: boolean;
  cweIds?: Array<string>;
  publishedOn?: string;
  affectedPackages?: Array<AffectedPackageResource>;
  withdrawn?: boolean;
};

export type IssueReleaseSetSeverityRestRequest = {
  /**
   * Issue release key
   */
  issueReleaseKey: string;
  /**
   * Software Quality
   */
  quality: 'MAINTAINABILITY' | 'RELIABILITY' | 'SECURITY';
  /**
   * Severity
   */
  severity: 'INFO' | 'LOW' | 'MEDIUM' | 'HIGH' | 'BLOCKER';
};

export type IssueReleaseClearSeverityWarningRestRequest = {
  /**
   * Issue release key
   */
  issueReleaseKey: string;
};

export type IssueReleaseStatusTransitionRequest = {
  /**
   * Issue release key
   */
  issueReleaseKey: string;
  /**
   * Transition key
   */
  transitionKey: 'CONFIRM' | 'REOPEN' | 'SAFE' | 'FIXED' | 'ACCEPT';
  /**
   * Transition comment
   */
  comment?: string;
};

export type IssueReleaseAddCommentRestRequest = {
  /**
   * Issue release key
   */
  issueReleaseKey: string;
  /**
   * comment
   */
  comment?: string;
};

export type AzureBillingRestResponse = {
  success?: boolean;
  message?: string;
};

export type PostJiraWorkItemRequestResource = {
  /**
   * Resource identifier
   */
  resourceId: string;
  /**
   * Resource type
   */
  resourceType: 'SONAR_ISSUE' | 'DEPENDENCY_RISK';
  /**
   * Sonar project identifier
   */
  sonarProjectId: string;
  /**
   * Work type identifier
   */
  workTypeId: string;
  /**
   * Work item summary
   */
  summary: string;
  /**
   * Work item description
   */
  description: string;
};

export type JiraWorkItemResource = {
  /**
   * Work item identifier
   */
  readonly id?: string;
  /**
   * Jira issue identifier
   */
  readonly jiraIssueId?: string;
  /**
   * Jira issue key
   */
  readonly jiraIssueKey?: string;
  /**
   * Jira issue URL
   */
  readonly jiraIssueUrl?: string;
  /**
   * Jira issue status
   */
  readonly jiraIssueStatus?: string;
};

export type PostJiraProjectBindingRequestResource = {
  /**
   * Sonar project identifier
   */
  sonarProjectId: string;
  /**
   * Jira instance binding identifier
   */
  jiraOrganizationId: string;
  /**
   * Jira project key
   */
  jiraProjectKey: string;
};

export type JiraProjectBindingResource = {
  /**
   * Jira project binding identifier
   */
  readonly id?: string;
  /**
   * Sonar project identifier
   */
  readonly sonarProjectId?: string;
  /**
   * Jira instance binding identifier
   */
  readonly jiraOrganizationId?: string;
  /**
   * Jira project key
   */
  readonly jiraProjectKey?: string;
};

export type PostJiraOrganizationBindingRequestResource = {
  /**
   * Base64-encoded OAuth state parameter
   */
  state: string;
  /**
   * OAuth authorization code (no whitespace)
   */
  authorizationCode: string;
};

export type JiraOrganizationBindingResource = {
  /**
   * Jira instance binding identifier
   */
  readonly id?: string;
  /**
   * Sonar organization UUID
   */
  readonly sonarOrganizationUuid?: string;
  /**
   * Jira instance URL
   */
  readonly jiraInstanceUrl?: string;
  /**
   * User who created or reauthorized the jira connection
   */
  readonly createdBy?: string;
  /**
   * Creation timestamp
   */
  readonly createdAt?: bigint;
};

export type OAuthResource = {
  /**
   * The resource's cloud ID
   */
  readonly cloudId?: string;
  /**
   * The resource's URL
   */
  readonly url?: string;
};

export type PostJiraOrganizationBindingResponseResource = {
  binding?: JiraOrganizationBindingResource;
  /**
   * Array of available resources to bind the instance to
   */
  readonly resources: Array<OAuthResource>;
};

/**
 * User binding creation request
 */
export type UserBindingCreationRequest = {
  bindingData: UserBindingCreationRequestBindingData;
  userId: string;
};

export type UserBindingCreationRequestBindingData = {
  code: string;
};

export type UserBindingResponse = {
  id?: string;
  user_id?: string;
  slack_user_id?: string;
  slack_workspace_id?: string;
  slack_workspace_name?: string;
  created_at?: bigint;
};

export type IntegrationConfigurationPostRequest = {
  integrationType: 'SLACK';
  clientId: string;
  clientSecret: string;
  signingSecret: string;
};

export type IntegrationConfigurationResponse = {
  id?: string;
  integrationType?: 'SLACK';
  clientId?: string;
  appId?: string;
};

export type AwarenessBannerClickedRequest = {
  bannerType?: 'ENABLE' | 'LEARN_MORE';
};

export type AwarenessBannerClickedResponse = {
  readonly id?: string;
};

export type FixSuggestionPostRequest = {
  projectKey?: string;
  /**
   * Issue key
   */
  issueId?: string;
  issue?: Issue;
};

export type Issue = {
  message: string;
  startLine: number;
  endLine: number;
  ruleKey: string;
  sourceCode: string;
};

export type ChangeDto = {
  startLine?: number;
  endLine?: number;
  newCode?: string;
};

export type FixSuggestionResponse = {
  id?: string;
  issueId?: string;
  explanation?: string;
  changes?: Array<ChangeDto>;
};

export type LicenseRestRequest = {
  /**
   * New license key
   */
  licenseKey?: string;
};

export type LicenseUploadActivationRequest = {
  /**
   * Contents of a valid .lic file
   */
  license?: string;
  /**
   * License key for the license
   */
  licenseKey?: string;
};

export type LegacyLicenseRestRequest = {
  /**
   * New license key
   */
  licenseKey?: string;
};

export type GitlabSynchronizationRunResource = {
  readonly id?: string;
};

export type PermissionMappingsPostRequest = {
  /**
   * Custom role name
   */
  role: string;
  permissions: RestPermissions;
};

export type RestPermissions = {
  /**
   * Browse
   */
  user: boolean;
  /**
   * See Source Code
   */
  codeViewer: boolean;
  /**
   * Administer Issues
   */
  issueAdmin: boolean;
  /**
   * Administer Security Hotspots
   */
  securityHotspotAdmin: boolean;
  /**
   * Administer
   */
  admin: boolean;
  /**
   * Execute Analysis
   */
  scan: boolean;
};

export type PermissionMappingsResource = {
  id?: string;
  role?: string;
  baseRole?: boolean;
  permissions?: RestPermissions;
};

export type GitlabConfigurationCreateRestRequest = {
  /**
   * Enable Gitlab authentication
   */
  enabled: boolean;
  /**
   * Gitlab Application id
   */
  applicationId: string;
  /**
   * Url of Gitlab instance for authentication (for instance https://gitlab.com)
   */
  url: string;
  /**
   * Set whether to synchronize groups
   */
  synchronizeGroups: boolean;
  allowedGroups: Array<string>;
  /**
   * Type of synchronization
   */
  provisioningType: 'JIT' | 'AUTO_PROVISIONING';
  /**
   * Allow user to sign up
   */
  allowUsersToSignUp?: boolean;
};

export type GitlabConfigurationResource = {
  readonly id?: string;
  enabled?: boolean;
  /**
   * Gitlab Application id
   */
  applicationId?: string;
  /**
   * Url of Gitlab instance for authentication (for instance https://gitlab.com/api/v4)
   */
  url?: string;
  synchronizeGroups?: boolean;
  /**
   * Root Gitlab groups allowed to authenticate and provisioned
   */
  allowedGroups?: Array<string>;
  allowUsersToSignUp?: boolean;
  provisioningType?: 'JIT' | 'AUTO_PROVISIONING';
  /**
   * Whether or not the provisioningToken is defined
   */
  readonly isProvisioningTokenSet?: boolean;
  /**
   * In case the GitLab configuration is incorrect, error message
   */
  readonly errorMessage?: string;
};

export type GithubConfigurationCreateRestRequest = {
  /**
   * Enable GitHub authentication
   */
  enabled: boolean;
  /**
   * The App ID is found on your GitHub App's page on GitHub at Settings > Developer Settings > GitHub Apps.
   */
  applicationId: string;
  /**
   * Synchronize GitHub team with SonarQube group memberships when users log in to SonarQube.
   * For each GitHub team they belong to, users will be associated to a group of the same name if it exists in SonarQube.
   *
   */
  synchronizeGroups: boolean;
  /**
   * The API url for a GitHub instance. https://api.github.com/ for Github.com, https://github.company.com/api/v3/ when using Github Enterprise
   */
  apiUrl: string;
  /**
   * The WEB url for a GitHub instance. https://github.com/ for Github.com, https://github.company.com/ when using GitHub Enterprise.
   *
   */
  webUrl: string;
  allowedOrganizations: Array<string>;
  /**
   * Type of synchronization
   */
  provisioningType: 'JIT' | 'AUTO_PROVISIONING';
  /**
   * Allow user to sign up
   */
  allowUsersToSignUp?: boolean;
  /**
   * Change project visibility based on GitHub repository visibility.
   * If disabled, every provisioned project will be private in SonarQube and visible only to users with explicit GitHub permissions for the corresponding repository.
   * Changes take effect at the next synchronization.
   *
   */
  projectVisibility?: boolean;
  /**
   * Admin consent to synchronize permissions from GitHub
   */
  userConsentRequiredAfterUpgrade?: boolean;
};

export type GithubConfigurationResource = {
  readonly id?: string;
  enabled?: boolean;
  /**
   * GitHub Application id
   */
  applicationId?: string;
  synchronizeGroups?: boolean;
  /**
   * Url of GitHub instance for API connectivity (for instance https://api.github.com)
   */
  apiUrl?: string;
  /**
   * Url of GitHub instance for authentication (for instance https://github.com)
   */
  webUrl?: string;
  /**
   * GitHub organizations allowed to authenticate and provisioned
   */
  allowedOrganizations?: Array<string>;
  provisioningType?: 'JIT' | 'AUTO_PROVISIONING';
  allowUsersToSignUp?: boolean;
  projectVisibility?: boolean;
  userConsentRequiredAfterUpgrade?: boolean;
  /**
   * In case the GitHub configuration is incorrect, error message
   */
  readonly errorMessage?: string;
};

export type BoundProjectCreateRestRequest = {
  /**
   * Key of the project to create
   */
  projectKey: string;
  /**
   * Name of the project to create
   */
  projectName: string;
  /**
   * Identifier of DevOps platform configuration to use. Use /dop-translation/dop-settings to retrieve the settings and their ID
   */
  devOpsPlatformSettingId: string;
  /**
   * Identifier of the DevOps platform repository to import:
   * - repository slug for GitHub and Bitbucket (Cloud and Server)
   * - repository id for GitLab
   * - repository name for Azure DevOps
   *
   */
  repositoryIdentifier: string;
  /**
   * Identifier of the DevOps platform project in which the repository is located.
   * This is only needed for Azure and BitBucket Server platforms
   *
   */
  projectIdentifier?: string;
  /**
   *   Project New Code Definition Type
   * New code definitions of the following types are allowed:
   * - PREVIOUS_VERSION
   * - NUMBER_OF_DAYS
   * - REFERENCE_BRANCH - will default to the main branch.
   *
   */
  newCodeDefinitionType?: string;
  /**
   *   Project New Code Definition Value
   * For each new code definition type, a different value is expected:
   * - no value, when the new code definition type is PREVIOUS_VERSION and REFERENCE_BRANCH
   * - a number between 1 and 90, when the new code definition type is NUMBER_OF_DAYS
   *
   */
  newCodeDefinitionValue?: string;
  /**
   * True if project is part of a mono repo.
   */
  monorepo: boolean;
};

export type BoundProjectCreateRestResponse = {
  /**
   * The identifier of the created project
   */
  projectId?: string;
  /**
   * The identifier of the binding between the created project and the DevOps platform project
   */
  bindingId?: string;
};

export type Impact = {
  softwareQuality?: 'MAINTAINABILITY' | 'RELIABILITY' | 'SECURITY';
  severity?: 'INFO' | 'LOW' | 'MEDIUM' | 'HIGH' | 'BLOCKER';
};

export type Parameter = {
  key?: string;
  readonly htmlDescription?: string;
  defaultValue?: string;
  type?: 'STRING' | 'TEXT' | 'BOOLEAN' | 'INTEGER' | 'FLOAT';
};

export type RuleCreateRestRequest = {
  /**
   * Key of the custom rule to create, must include the repository
   */
  key: string;
  /**
   * Key of the rule template to be used to create the custom rule
   */
  templateKey: string;
  /**
   * Rule name
   */
  name: string;
  /**
   * Rule description in markdown format
   */
  markdownDescription: string;
  /**
   * Rule status
   */
  status?: 'BETA' | 'DEPRECATED' | 'READY' | 'REMOVED';
  /**
   * Custom rule parameters
   */
  parameters?: Array<Parameter>;
  /**
   * Clean code attribute
   */
  cleanCodeAttribute?:
    | 'CONVENTIONAL'
    | 'FORMATTED'
    | 'IDENTIFIABLE'
    | 'CLEAR'
    | 'COMPLETE'
    | 'EFFICIENT'
    | 'LOGICAL'
    | 'DISTINCT'
    | 'FOCUSED'
    | 'MODULAR'
    | 'TESTED'
    | 'LAWFUL'
    | 'RESPECTFUL'
    | 'TRUSTWORTHY';
  /**
   * Impacts
   */
  impacts: Array<Impact>;
  /**
   * Severity
   */
  severity?: string;
  /**
   * Rule type
   */
  type?: 'CODE_SMELL' | 'BUG' | 'VULNERABILITY' | 'SECURITY_HOTSPOT';
};

export type RuleDescriptionSectionContextRestResponse = {
  key?: string;
  displayName?: string;
};

export type RuleDescriptionSectionRestResponse = {
  readonly key?: string;
  readonly content?: string;
  context?: RuleDescriptionSectionContextRestResponse;
};

export type RuleRestResponse = {
  id?: string;
  key?: string;
  repositoryKey?: string;
  name?: string;
  severity?: string;
  type?: 'CODE_SMELL' | 'BUG' | 'VULNERABILITY' | 'SECURITY_HOTSPOT';
  impacts?: Array<Impact>;
  cleanCodeAttribute?:
    | 'CONVENTIONAL'
    | 'FORMATTED'
    | 'IDENTIFIABLE'
    | 'CLEAR'
    | 'COMPLETE'
    | 'EFFICIENT'
    | 'LOGICAL'
    | 'DISTINCT'
    | 'FOCUSED'
    | 'MODULAR'
    | 'TESTED'
    | 'LAWFUL'
    | 'RESPECTFUL'
    | 'TRUSTWORTHY';
  cleanCodeAttributeCategory?:
    | 'ADAPTABLE'
    | 'CONSISTENT'
    | 'INTENTIONAL'
    | 'RESPONSIBLE';
  status?: 'BETA' | 'DEPRECATED' | 'READY' | 'REMOVED';
  external?: boolean;
  createdAt?: string;
  descriptionSections?: Array<RuleDescriptionSectionRestResponse>;
  markdownDescription?: string;
  gapDescription?: string;
  htmlNote?: string;
  markdownNote?: string;
  educationPrinciples?: Array<string>;
  template?: boolean;
  templateId?: string;
  tags?: Array<string>;
  systemTags?: Array<string>;
  languageKey?: string;
  languageName?: string;
  parameters?: Array<Parameter>;
  remediationFunctionType?: string;
  remediationFunctionGapMultiplier?: string;
  remediationFunctionBaseEffort?: string;
};

export type GroupCreateRestRequest = {
  /**
   * Name for the new group. Must be unique. The value 'anyone' is reserved and cannot be used.
   */
  name: string;
  /**
   * Description for the new group.
   */
  description?: string;
};

export type GroupRestResponse = {
  readonly id?: string;
  name?: string;
  description?: string;
  readonly managed?: boolean;
  readonly default?: boolean;
};

export type GroupMembershipCreateRestRequest = {
  /**
   * ID of the user to add to group.
   */
  userId?: string;
  /**
   * ID of the group where a member needs to be added.
   */
  groupId?: string;
};

export type GroupMembershipRestResponse = {
  readonly id?: string;
  readonly groupId?: string;
  readonly userId?: string;
};

export type AtlassianAuthenticationDetailsResource = {
  /**
   * Atlassian 3LO App Client ID
   */
  clientId?: string;
  /**
   * Atlassian 3LO App Secret
   */
  secret?: string;
};

export type AtlassianAuthenticationDetailsResultResource = {
  /**
   * Atlassian 3LO App Client ID
   */
  readonly clientId?: string;
};

export type UpdateFieldListString = {
  value?: Array<string>;
  defined?: boolean;
};

export type UserUpdateRestRequest = {
  /**
   * User login
   */
  login?: string;
  /**
   * User first name and last name
   */
  name?: string;
  /**
   * Email
   */
  email?: string;
  scmAccounts?: UpdateFieldListString;
  /**
   * New identity provider. Only providers configured in your platform are supported. This could be: github, gitlab, bitbucket, saml, LDAP, LDAP_{serverKey}
   * (according to your server configuration file).
   * Warning: when this is updated, the user will only be able to authenticate using the new identity provider. Also, it is not possible to remove the identity provider of a user.
   *
   */
  externalProvider?: string;
  /**
   * New external login, usually the login used in the authentication system.
   */
  externalLogin?: string;
  /**
   * New external id in the authentication system.
   */
  externalId?: string;
};

export type EmailConfigurationUpdateRestRequest = {
  /**
   * URL of your SMTP server
   */
  host?: string;
  /**
   * Port of your SMTP server (usually 25, 587 or 465)
   */
  port?: string;
  /**
   * Security protocol used to connect to your SMTP server (SSLTLS is recommended)
   */
  securityProtocol?: 'NONE' | 'SSLTLS' | 'STARTTLS';
  /**
   * Address emails will come from
   */
  fromAddress?: string;
  /**
   * Name emails will come from (usually "SonarQube")
   */
  fromName?: string;
  /**
   * Prefix added to email so they can be easily recognized (usually "[SonarQube]")
   */
  subjectPrefix?: string;
  /**
   * Authentication method used to connect to the SMTP server. OAuth is only supported for Microsoft Exchange
   */
  authMethod?: 'BASIC' | 'OAUTH';
  /**
   * For Basic and OAuth authentication: username used to authenticate to the SMTP server
   */
  username?: string;
  /**
   * For basic authentication: password used to authenticate to the SMTP server
   */
  basicPassword?: string;
  /**
   * For OAuth authentication: host of the Identity Provider issuing access tokens
   */
  oauthAuthenticationHost?: string;
  /**
   * For OAuth authentication: Client ID provided by Microsoft Exchange when registering the application
   */
  oauthClientId?: string;
  /**
   * For OAuth authentication: Client password provided by Microsoft Exchange when registering the application
   */
  oauthClientSecret?: string;
  /**
   * For OAuth authentication: Microsoft tenant
   */
  oauthTenant?: string;
};

export type LicenseProfilesUpdateRestRequest = {
  /**
   * The name of the license policy
   */
  name?: string;
  /**
   * Whether this license policy is the default or not
   */
  default?: boolean;
};

export type LicensePolicyLicenseUpdateRestRequest = {
  /**
   * The new status of this license.
   */
  policy: 'ALLOW' | 'DENY';
};

export type LicensePolicyLicenseResource = {
  id?: string;
  spdxLicenseId?: string;
  name?: string;
  category?:
    | 'UNKNOWN'
    | 'COPYLEFT_WEAK'
    | 'COPYLEFT_STRONG'
    | 'COPYLEFT_NETWORK'
    | 'COPYLEFT_MAXIMAL'
    | 'PERMISSIVE_STANDARD'
    | 'PERMISSIVE_AMATEUR';
  /**
   * The policy status of this license.
   */
  policy?: 'ALLOW' | 'DENY';
};

export type LicenseProfileCategoryUpdateRestRequest = {
  /**
   * The new status of this category.
   */
  policy: 'ALLOW' | 'DENY';
};

export type LicenseProfileCategoryResource = {
  id?: string;
  key?:
    | 'UNKNOWN'
    | 'COPYLEFT_WEAK'
    | 'COPYLEFT_STRONG'
    | 'COPYLEFT_NETWORK'
    | 'COPYLEFT_MAXIMAL'
    | 'PERMISSIVE_STANDARD'
    | 'PERMISSIVE_AMATEUR';
  /**
   * The policy status of this category.
   */
  policy?: 'ALLOW' | 'DENY';
};

export type AssignedProjectsUpdateRestRequest = {
  /**
   * The id of the license profile that should be used when analyzing the project for license issues.
   */
  licenseProfileUuid: string;
  /**
   * The key of the project that should be assigned to the license profile.
   */
  projectKey: string;
};

export type IssueReleaseUpdateCommentRestRequest = {
  /**
   * Issue release change key
   */
  issueReleaseChangeKey: string;
  /**
   * Comment text
   */
  comment: string;
};

export type FeatureEnablementRequest = {
  /**
   * Whether SCA is enabled or not
   */
  enablement?: boolean;
};

export type FeatureEnablementResource = {
  enablement?: boolean;
};

export type JiraWorkTypesSelectionResource = {
  /**
   * The Sonar project ID
   */
  sonarProjectId?: string;
  /**
   * An array with the selected work type ids
   */
  selectedWorkTypes?: Array<string>;
};

export type PatchJiraProjectBindingRequestResource = {
  /**
   * Sonar project identifier
   */
  sonarProjectId: string;
  /**
   * Jira project key
   */
  jiraProjectKey: string;
};

export type PatchJiraOrganizationBindingRequestResource = {
  /**
   * Sonar organization UUID
   */
  sonarOrganizationUuid: string;
  /**
   * Jira cloud ID to bind with the organization
   */
  jiraCloudId: string;
  /**
   * Jira instance URL
   */
  jiraInstanceUrl: string;
};

export type RuleTypeMapping = {
  /**
   * Rule type
   */
  type: 'CODE_SMELL' | 'BUG' | 'VULNERABILITY' | 'SECURITY_HOTSPOT';
  /**
   * List of severities
   */
  severities: Array<'BLOCKER' | 'CRITICAL' | 'MAJOR' | 'MINOR' | 'INFO'>;
};

export type SandboxSettingsResource = {
  /**
   * Whether sandbox is enabled globally
   */
  enabled?: boolean;
  /**
   * Default value for projects
   */
  defaultValue?: boolean;
  /**
   * Allow projects to override settings
   */
  allowOverride?: boolean;
  /**
   * Software quality mappings (MQR mode)
   */
  softwareQualities?: Array<SoftwareQualityMapping>;
  /**
   * Rule type mappings (Standard Experience mode)
   */
  types?: Array<RuleTypeMapping>;
};

export type SoftwareQualityMapping = {
  /**
   * Software quality
   */
  softwareQuality: 'MAINTAINABILITY' | 'RELIABILITY' | 'SECURITY';
  /**
   * List of impact severities
   */
  impactSeverities: Array<'INFO' | 'LOW' | 'MEDIUM' | 'HIGH' | 'BLOCKER'>;
};

export type SandboxSettingsProjectResource = {
  /**
   * Whether sandbox is enabled for this project
   */
  enabled?: boolean;
  /**
   * Software quality mappings (MQR mode)
   */
  softwareQualities?: Array<SoftwareQualityMapping>;
  /**
   * Rule type mappings (Standard Experience mode)
   */
  types?: Array<RuleTypeMapping>;
  /**
   * Whether project settings override instance settings
   */
  overridden?: boolean;
};

export type IntegrationConfigurationPatchRequest = {
  clientId?: string;
  clientSecret?: string;
  signingSecret?: string;
};

export type DevOpsPermissionMappingUpdateRequest = {
  permissions?: PermissionMappingUpdate;
};

export type PermissionMappingUpdate = {
  user?: boolean;
  codeViewer?: boolean;
  issueAdmin?: boolean;
  securityHotspotAdmin?: boolean;
  admin?: boolean;
  scan?: boolean;
};

export type GitlabConfigurationUpdateRestRequest = {
  /**
   * Enable Gitlab authentication
   */
  enabled?: boolean;
  /**
   * Gitlab Application id
   */
  applicationId?: string;
  /**
   * Url of Gitlab instance for authentication (for instance https://gitlab.com/api/v4)
   */
  url?: string;
  /**
   * Secret of the application
   */
  secret?: string;
  /**
   * Set whether to synchronize groups
   */
  synchronizeGroups?: boolean;
  allowedGroups?: UpdateFieldListString;
  /**
   * Type of synchronization
   */
  provisioningType?: 'JIT' | 'AUTO_PROVISIONING';
  /**
   * Allow user to sign up
   */
  allowUsersToSignUp?: boolean;
  /**
   * Gitlab token for provisioning
   */
  provisioningToken?: string;
};

export type GithubConfigurationUpdateRestRequest = {
  /**
   * Enable GitHub authentication
   */
  enabled?: boolean;
  /**
   * GitHub Client ID
   */
  clientId?: string;
  /**
   * GitHub Client secret
   */
  clientSecret?: string;
  /**
   * GitHub Application id
   */
  applicationId?: string;
  /**
   * GitHub Private key
   */
  privateKey?: string;
  /**
   * Set whether to synchronize groups
   */
  synchronizeGroups?: boolean;
  /**
   * Url of GitHub instance for API connectivity (for instance https://api.github.com)
   */
  apiUrl?: string;
  /**
   * Url of GitHub instance for authentication (for instance https://github.com)
   */
  webUrl?: string;
  allowedOrganizations?: UpdateFieldListString;
  /**
   * Type of synchronization
   */
  provisioningType?: 'JIT' | 'AUTO_PROVISIONING';
  /**
   * Allow user to sign up
   */
  allowUsersToSignUp?: boolean;
  /**
   * Sync project visibility
   */
  projectVisibility?: boolean;
  /**
   * Admin consent to synchronize permissions from GitHub
   */
  userConsentRequiredAfterUpgrade?: boolean;
};

export type ModeResource = {
  mode: 'MQR' | 'STANDARD_EXPERIENCE';
  readonly modified?: boolean;
};

export type GroupUpdateRestRequest = {
  /**
   * Group name
   */
  name?: string;
  /**
   * Description of the group
   */
  description?: string;
};

export type PageRestResponse = {
  pageIndex?: number;
  pageSize?: number;
  total?: number;
};

export type UsersSearchRestResponse = {
  users?: Array<UserRestResponseForAdmins>;
  page?: PageRestResponse;
};

export type DatabaseMigrationsResponse = {
  status?: string;
  completedSteps?: number;
  totalSteps?: number;
  startedAt?: string;
  message?: string;
  expectedFinishTimestamp?: string;
};

export type Health = {
  status?: 'GREEN' | 'YELLOW' | 'RED';
  causes?: Array<string>;
};

export type EmailConfigurationSearchRestResponse = {
  emailConfigurations?: Array<EmailConfigurationResource>;
  page?: PageRestResponse;
};

export type SelfTestHttpCallResource = {
  attemptedUrl?: string;
  attemptedMethod?: string;
  responseCode?: number;
  responseBody?: string;
  responseBodyAppearsValid?: boolean;
  responseHeaders?: Array<Array<string>>;
};

export type SelfTestResponse = {
  featureEnabled?: boolean;
  selfTestPassed?: boolean;
  cliVersionCheck?: SelfTestHttpCallResource;
  vulnerabilityDetailsCheck?: SelfTestHttpCallResource;
};

export type SelfTestSpringConfigurationResponse = {
  springVersion?: string;
};

export type RiskReportItem = {
  projectKey?: string;
  projectName?: string;
  branchKey?: string;
  riskTitle?: string;
  riskType?: 'VULNERABILITY' | 'PROHIBITED_LICENSE';
  riskSeverity?: 'INFO' | 'LOW' | 'MEDIUM' | 'HIGH' | 'BLOCKER';
  riskStatus?: 'OPEN' | 'ACCEPT' | 'CONFIRM' | 'SAFE' | 'FIXED';
  statusChanges?: Array<StatusChange>;
  vulnerabilityId?: string;
  cvssScore?: number;
  cweIds?: Array<string>;
  publishedOn?: string;
  createdAt?: string;
  packageUrl?: string;
  riskUrl?: string;
  dependencyChains?: Array<Array<string>>;
  scope?: string;
  productionScope?: boolean;
};

export type StatusChange = {
  comment?: string;
  newStatus?: string;
  createdAt?: string;
};

export type BranchResource = {
  uuid?: string;
  key?: string;
  isPullRequest?: boolean;
  projectKey?: string;
  projectName?: string;
};

export type ReleasesSearchRestResponse = {
  releases?: Array<ReleaseSearchResource>;
  packageManagerCounts?: Array<ScaReleaseByPackageManagerCountDto>;
  branches?: Array<BranchResource>;
  countWithoutFilters?: number;
  page?: PageRestResponse;
};

export type ScaReleaseByPackageManagerCountDto = {
  packageManager?: string;
  releaseCount?: number;
};

export type DependencyResource = {
  key?: string;
  direct?: boolean;
  scope?: string;
  productionScope?: boolean;
  userDependencyFilePath?: string;
  lockfileDependencyFilePath?: string;
  chains?: Array<Array<string>>;
  newlyIntroduced?: boolean;
};

export type IssueResource = {
  key?: string;
  severity?: string;
  showIncreasedSeverityWarning?: boolean;
  type?: 'VULNERABILITY' | 'PROHIBITED_LICENSE';
  quality?: 'MAINTAINABILITY' | 'RELIABILITY' | 'SECURITY';
  createdAt?: string;
  assignee?: UserResource;
  vulnerabilityId?: string;
  cweIds?: Array<string>;
  cvssScore?: string;
  spdxLicenseId?: string;
};

export type ReleaseDetailResource = {
  key?: string;
  branchUuid?: string;
  packageUrl?: string;
  packageManager?: string;
  packageName?: string;
  version?: string;
  licenseExpression?: string;
  known?: boolean;
  knownPackage?: boolean;
  newlyIntroduced?: boolean;
  directSummary?: boolean;
  scopeSummary?: string;
  productionScopeSummary?: boolean;
  dependencies?: Array<DependencyResource>;
  issues?: Array<IssueResource>;
  branch?: BranchResource;
};

export type LicenseProfileCollectionActions = {
  create?: boolean;
};

export type LicenseProfileIndexRestResponse = {
  licenseProfiles?: Array<LicenseProfileResource>;
  actions?: LicenseProfileCollectionActions;
};

export type LicenseProfileDetailsResource = {
  profile?: LicenseProfileResource;
  categories?: Array<LicenseProfileCategoryResource>;
  licenses?: Array<LicensePolicyLicenseResource>;
};

export type AssignableProjectResource = {
  projectKey?: string;
  projectName?: string;
  assignedToLicenseProfile?: boolean;
};

export type AssignableProjectsIndexRestResponse = {
  assignableProjects?: Array<AssignableProjectResource>;
  page?: PageRestResponse;
};

export type IssueReleaseResource = {
  key?: string;
  severity?: string;
  originalSeverity?: string;
  manualSeverity?: string;
  showIncreasedSeverityWarning?: boolean;
  release?: ReleaseSearchResource;
  type?: 'VULNERABILITY' | 'PROHIBITED_LICENSE';
  quality?: 'MAINTAINABILITY' | 'RELIABILITY' | 'SECURITY';
  status?: string;
  createdAt?: string;
  assignee?: UserResource;
  commentCount?: number;
  vulnerabilityId?: string;
  cweIds?: Array<string>;
  cvssScore?: string;
  withdrawn?: boolean;
  spdxLicenseId?: string;
  transitions?: Array<'CONFIRM' | 'REOPEN' | 'SAFE' | 'FIXED' | 'ACCEPT'>;
  actions?: Array<'COMMENT' | 'ASSIGN' | 'SET_SEVERITY'>;
};

export type IssuesReleasesSearchRestResponse = {
  issuesReleases?: Array<IssueReleaseResource>;
  branches?: Array<IssueReleaseBranchResource>;
  countWithoutFilters?: number;
  page?: PageRestResponse;
};

export type IssueReleaseChangeDiffResource = {
  fieldName?: string;
  oldValue?: string;
  newValue?: string;
};

export type IssueReleaseChangeResource = {
  key?: string;
  createdAt?: string;
  user?: UserResource;
  markdownComment?: string;
  htmlComment?: string;
  changeData?: Array<IssueReleaseChangeDiffResource>;
  actions?: Array<'EDIT_COMMENT' | 'DELETE_COMMENT'>;
};

export type IssuesReleasesChangesRestResponse = {
  changelog?: Array<IssueReleaseChangeResource>;
};

export type ScaFeatureEnabledResource = {
  enabled?: boolean;
};

export type ScaCliInfoRestResponse = {
  id?: string;
  filename?: string;
  sha256?: string;
  os?: string;
  arch?: string;
};

export type AnalysisErrorResource = {
  code?:
    | 'UNKNOWN'
    | 'NO_DEPENDENCIES_FOUND'
    | 'DEPENDENCY_FILES_PARSE_ERROR'
    | 'UNSUPPORTED_PLATFORM'
    | 'INEXACT_VERSIONS'
    | 'MISSING_LOCKFILE';
  path?: string;
  message?: string;
};

export type AnalysisResource = {
  status?: 'FAILED' | 'OUTDATED' | 'COMPLETED';
  failedReason?: string;
  errors?: Array<AnalysisErrorResource>;
  parsedFiles?: Array<string>;
};

export type JiraWorkTypeFieldResultResource = {
  /**
   * The field key
   */
  readonly key?: string;
  /**
   * The field name
   */
  readonly name?: string;
  /**
   * Whether the field is required
   */
  readonly required?: boolean;
  /**
   * Whether the field has a default value
   */
  readonly hasDefaultValue?: boolean;
};

export type JiraWorkTypeResultResource = {
  /**
   * the Jira work type id
   */
  readonly id?: string;
  /**
   * the Jira work type name
   */
  readonly name?: string;
  /**
   * the Jira work type description
   */
  readonly description?: string;
  /**
   * true, if the Jira work type is a subtask
   */
  readonly subtask?: boolean;
  /**
   * the Jira work type hierarchy
   */
  readonly hierarchyLevel?: number;
  /**
   * true, if the Jira work type is selected
   */
  readonly selected?: boolean;
  /**
   * Array of field metadata for the specified work type. (Optional)
   */
  readonly fields?: Array<JiraWorkTypeFieldResultResource>;
};

export type JiraProjectResultResource = {
  /**
   * the name of the project
   */
  readonly name?: string;
  /**
   * the key of the project
   */
  readonly key?: string;
};

export type LinkedIssuesCountResource = {
  /**
   * Count of linked Jira issues
   */
  readonly count?: number;
};

export type IntegrationConfigurationSearchResponse = {
  integrationConfigurations?: Array<IntegrationConfigurationResponse>;
};

export type SupportedRulesDto = {
  rules?: Array<string>;
};

export type LlmModelDto = {
  key?: string;
  name?: string;
  recommended?: boolean;
};

export type LlmProviderResponseDto = {
  key?: string;
  name?: string;
  selfHosted?: boolean;
  models?: Array<LlmModelDto>;
};

export type ServiceInfo = {
  status?:
    | 'CONNECTION_ERROR'
    | 'SERVICE_ERROR'
    | 'SUCCESS'
    | 'TIMEOUT'
    | 'UNAUTHORIZED';
};

export type FixSuggestionIssueResponse = {
  issueId?: string;
  aiSuggestion?:
    | 'AVAILABLE'
    | 'NOT_AVAILABLE_FILE_LEVEL_ISSUE'
    | 'NOT_AVAILABLE_UNSUPPORTED_RULE'
    | 'NOT_AVAILABLE_FILE_SIZE';
};

export type FeatureEnablementResponse = {
  enablement?:
    | 'DISABLED'
    | 'ENABLED_FOR_ALL_PROJECTS'
    | 'ENABLED_FOR_SOME_PROJECTS';
  enabledProjectKeys?: Array<string>;
  provider?: ProviderResponseDto;
};

export type ProviderResponseDto = {
  key?: string;
  modelKey?: string;
  endpoint?: string;
};

export type PurchasableFeatureRestResponse = {
  featureKey?: string;
  parent?: string;
  isEnabled?: boolean;
  isAvailable?: boolean;
  url?: string;
};

export type LicenseFeatureRestResponse = {
  name?: string;
  parent?: string;
  startDate?: string;
  endDate?: string;
};

export type LicenseRestResponse = {
  expirationDate?: string;
  lastRefreshDate?: string;
  edition?: string;
  features?: Array<LicenseFeatureRestResponse>;
  maxLoc?: bigint;
  loc?: bigint;
  serverId?: string;
  type?: string;
  contactEmail?: string;
  remainingLocThreshold?: bigint;
  canActivateGracePeriod?: boolean;
  gracePeriodEndDate?: string;
  gracePeriodExpired?: boolean;
  extraDays?: number;
  startDate?: string;
  activatedOnline?: boolean;
  licenseKey?: string;
  expired?: boolean;
  validEdition?: boolean;
  validServerId?: boolean;
  officialDistribution?: boolean;
  supported?: boolean;
  legacy?: boolean;
  disabled?: boolean;
};

export type ProjectBinding = {
  id: string;
  devOpsPlatformSettingId: string;
  projectId: string;
  projectKey: string;
  repository?: string;
  slug?: string;
};

export type ProjectBindingsSearchRestResponse = {
  projectBindings?: Array<ProjectBinding>;
  page?: PageRestResponse;
};

export type PermissionMappingsSearchRestResponse = {
  permissionMappings?: Array<PermissionMappingsResource>;
};

export type GitlabConfigurationSearchRestResponse = {
  gitlabConfigurations?: Array<GitlabConfigurationResource>;
  page?: PageRestResponse;
};

export type GithubConfigurationSearchRestResponse = {
  githubConfigurations?: Array<GithubConfigurationResource>;
  page?: PageRestResponse;
};

export type DopSettingsResource = {
  readonly id?: string;
  /**
   * Supported DevOps Platform are: github, gitlab, azure, bitbucketcloud, bitbucket_server
   */
  type?: string;
  key?: string;
  url?: string;
  appId?: string;
};

export type DopSettingsRestResponse = {
  dopSettings?: Array<DopSettingsResource>;
  page?: PageRestResponse;
};

export type GroupsSearchRestResponse = {
  groups?: Array<GroupRestResponse>;
  page?: PageRestResponse;
};

export type GroupsMembershipSearchRestResponse = {
  groupMemberships?: Array<GroupMembershipRestResponse>;
  page?: PageRestResponse;
};

export type E = {
  id?: string;
  branchId?: string;
  type?: 'file_graph' | 'namespace_graph';
  ecosystem?: 'java' | 'js' | 'ts' | 'py' | 'cs' | 'xoo';
  perspectiveKey?: string;
  graphVersion?: string;
};

export type P = {
  graphs?: Array<E>;
};

export type JreInfoRestResponse = {
  id?: string;
  filename?: string;
  sha256?: string;
  javaPath?: string;
  os?: string;
  arch?: string;
};

export type EngineInfoRestResponse = {
  filename?: string;
  sha256?: string;
};

export type ActiveRule = {
  ruleKey?: RuleKey;
  name?: string;
  severity?: string;
  createdAt?: string;
  updatedAt?: string;
  internalKey?: string;
  language?: string;
  templateRuleKey?: string;
  qProfileKey?: string;
  deprecatedKeys?: Array<RuleKey>;
  params?: Array<Param>;
  impacts?: {
    [key: string]: 'INFO' | 'LOW' | 'MEDIUM' | 'HIGH' | 'BLOCKER';
  };
};

export type Param = {
  key?: string;
  value?: string;
};

export type RuleKey = {
  repository?: string;
  rule?: string;
};

/**
 * Metric for a component
 * A metric captured from a project
 */
export type Metric = {
  key: string;
  name: string;
  type: string;
  domain: string;
  hidden: boolean;
  description: string;
  qualitative: boolean;
  higherValuesAreBetter: boolean;
};

/**
 * Used to represent a paged response
 */
export type Paging = {
  total: number;
  pageSize: number;
  pageIndex: number;
};

/**
 * Measures from a project
 */
export type Measure = {
  value: string;
  metric: string;
  period: {
    value: boolean;
    bestValue: string;
  };
};

/**
 * A component is a representation of a Project in Sonarqube
 */
export type Component = {
  key: string;
  name: string;
  managed: string;
  revision: string;
  qualifier: string;
  visibility: string;
  lastAnalysisDate: string;
};

/**
 * Issue Search Response
 * Response object from the Issue Search API
 */
export type IssueSearchResponse = {
  rules: Array<{
    key: string;
    lang: string;
    name: string;
    status: string;
    langName: string;
  }>;
  users: Array<{
    name: string;
    login: string;
    active: boolean;
    avatar: string;
  }>;
  facets: Array<{
    values: Array<{
      val: string;
      count: number;
    }>;
    property: string;
  }>;
  issues: Array<{
    key: string;
    attr: {
      'jira-issue-key': string;
    };
    hash: string;
    line: number;
    rule: string;
    tags: Array<string>;
    type: string;
    flows: Array<{
      locations: Array<{
        msg: string;
        textRange: {
          endLine: number;
          endOffset: number;
          startLine: number;
          startOffset: number;
        };
        msgFormattings: Array<{
          end: number;
          type: string;
          start: number;
        }>;
      }>;
    }>;
    author: string;
    effort: string;
    status: string;
    actions: Array<string>;
    impacts: Array<{
      severity: string;
      softwareQuality: string;
    }>;
    message: string;
    project: string;
    comments: Array<{
      key: string;
      login: string;
      htmlText: string;
      markdown: string;
      createdAt: string;
      updatable: boolean;
    }>;
    severity: string;
    component: string;
    textRange: {
      endLine: number;
      endOffset: number;
      startLine: number;
      startOffset: number;
    };
    updateDate: string;
    issueStatus: string;
    transitions: Array<string>;
    codeVariants: Array<string>;
    creationDate: string;
    prioritizedRule: boolean;
    quickFixAvailable: boolean;
    cleanCodeAttribute: string;
    messageFormattings: Array<{
      end: number;
      type: string;
      start: number;
    }>;
    ruleDescriptionContextKey: string;
    cleanCodeAttributeCategory: string;
  }>;
  paging: Paging;
  components: Array<{
    key: string;
    name: string;
    path?: string;
    enabled: boolean;
    longName: string;
    qualifier: string;
  }>;
};

/**
 * Response type for searching for a project
 */
export type ProjectSearchResponse = {
  paging: Paging;
  components: Array<Component>;
};

/**
 * Generated schema for Root
 * Response from the /measures/component endpoint
 */
export type MeasureComponentResponse = {
  period: {
    date: string;
    mode: string;
    parameter: string;
  };
  metrics: Array<Metric>;
  component: {
    key: string;
    name: string;
    path: string;
    language: string;
    measures: Array<Measure>;
    qualifier: string;
  };
};

export type UserCreateRestRequestWritable = {
  /**
   * User email
   */
  email?: string;
  /**
   * Specify if the user should be authenticated from SonarQube server or from an external authentication system. Password should not be set when local is set to false.
   */
  local?: boolean;
  /**
   * User login
   */
  login: string;
  /**
   * User name
   */
  name: string;
  /**
   * User password. Only mandatory when creating local user, otherwise it should not be set
   */
  password?: string;
  /**
   * List of SCM accounts.
   */
  scmAccounts?: Array<string>;
};

export type UserRestResponseForAdminsWritable = {
  login?: string;
  name?: string;
  email?: string;
  externalLogin?: string;
  externalProvider?: string;
  externalId?: string;
  avatar?: string;
  scmAccounts?: Array<string>;
};

export type EmailConfigurationCreateRestRequestWritable = {
  /**
   * URL of your SMTP server
   */
  host: string;
  /**
   * Port of your SMTP server (usually 25, 587 or 465)
   */
  port: string;
  /**
   * Security protocol used to connect to your SMTP server (SSLTLS is recommended)
   */
  securityProtocol: 'NONE' | 'SSLTLS' | 'STARTTLS';
  /**
   * Address emails will come from
   */
  fromAddress: string;
  /**
   * Name emails will come from (usually "SonarQube")
   */
  fromName: string;
  /**
   * Prefix added to email so they can be easily recognized (usually "[SonarQube]")
   */
  subjectPrefix: string;
  /**
   * Authentication method used to connect to the SMTP server. OAuth is only supported for Microsoft Exchange
   */
  authMethod: 'BASIC' | 'OAUTH';
  /**
   * For Basic and OAuth authentication: username used to authenticate to the SMTP server
   */
  username: string;
  /**
   * For basic authentication: password used to authenticate to the SMTP server
   */
  basicPassword?: string;
  /**
   * For OAuth authentication: host of the Identity Provider issuing access tokens
   */
  oauthAuthenticationHost?: string;
  /**
   * For OAuth authentication: Client ID provided by Microsoft Exchange when registering the application
   */
  oauthClientId?: string;
  /**
   * For OAuth authentication: Client secret provided by Microsoft Exchange when registering the application
   */
  oauthClientSecret?: string;
  /**
   * For OAuth authentication: Microsoft tenant
   */
  oauthTenant?: string;
};

export type EmailConfigurationResourceWritable = {
  /**
   * URL of your SMTP server
   */
  host?: string;
  /**
   * Port of your SMTP server (usually 25, 587 or 465)
   */
  port?: string;
  /**
   * Security protocol used to connect to your SMTP server (SSLTLS is recommended)
   */
  securityProtocol?: 'NONE' | 'SSLTLS' | 'STARTTLS';
  /**
   * Address emails will come from
   */
  fromAddress?: string;
  /**
   * Name emails will come from (usually "SonarQube")
   */
  fromName?: string;
  /**
   * Prefix added to email so they can be easily recognized (usually "[SonarQube]")
   */
  subjectPrefix?: string;
  /**
   * Authentication method used to connect to the SMTP server. OAuth is only supported for Microsoft Exchange
   */
  authMethod?: 'BASIC' | 'OAUTH';
  /**
   * For Basic and OAuth authentication: username used to authenticate to the SMTP server
   */
  username?: string;
  /**
   * For Basic authentication: has the password field been set?
   */
  isBasicPasswordSet?: boolean;
  /**
   * For OAuth authentication: host of the Identity Provider issuing access tokens
   */
  oauthAuthenticationHost?: string;
  /**
   * For OAuth authentication: has the Client ID field been set?
   */
  isOauthClientIdSet?: boolean;
  /**
   * For OAuth authentication: has the Client secret field been set?
   */
  isOauthClientSecretSet?: boolean;
  /**
   * For OAuth authentication: Microsoft tenant
   */
  oauthTenant?: string;
};

export type GitlabConfigurationCreateRestRequestWritable = {
  /**
   * Enable Gitlab authentication
   */
  enabled: boolean;
  /**
   * Gitlab Application id
   */
  applicationId: string;
  /**
   * Url of Gitlab instance for authentication (for instance https://gitlab.com)
   */
  url: string;
  /**
   * Secret of the application
   */
  secret: string;
  /**
   * Set whether to synchronize groups
   */
  synchronizeGroups: boolean;
  allowedGroups: Array<string>;
  /**
   * Type of synchronization
   */
  provisioningType: 'JIT' | 'AUTO_PROVISIONING';
  /**
   * Gitlab token for provisioning
   */
  provisioningToken?: string;
  /**
   * Allow user to sign up
   */
  allowUsersToSignUp?: boolean;
};

export type GitlabConfigurationResourceWritable = {
  enabled?: boolean;
  /**
   * Gitlab Application id
   */
  applicationId?: string;
  /**
   * Url of Gitlab instance for authentication (for instance https://gitlab.com/api/v4)
   */
  url?: string;
  synchronizeGroups?: boolean;
  /**
   * Root Gitlab groups allowed to authenticate and provisioned
   */
  allowedGroups?: Array<string>;
  allowUsersToSignUp?: boolean;
  provisioningType?: 'JIT' | 'AUTO_PROVISIONING';
};

export type GithubConfigurationCreateRestRequestWritable = {
  /**
   * Enable GitHub authentication
   */
  enabled: boolean;
  /**
   * Client ID provided by GitHub when registering the application.
   */
  clientId: string;
  /**
   * Client password provided by GitHub when registering the application.
   */
  clientSecret: string;
  /**
   * The App ID is found on your GitHub App's page on GitHub at Settings > Developer Settings > GitHub Apps.
   */
  applicationId: string;
  /**
   * Your GitHub App's private key. You can generate a .pem file from your GitHub App's page under Private keys.
   * Copy and paste the whole contents of the file here.
   *
   */
  privateKey: string;
  /**
   * Synchronize GitHub team with SonarQube group memberships when users log in to SonarQube.
   * For each GitHub team they belong to, users will be associated to a group of the same name if it exists in SonarQube.
   *
   */
  synchronizeGroups: boolean;
  /**
   * The API url for a GitHub instance. https://api.github.com/ for Github.com, https://github.company.com/api/v3/ when using Github Enterprise
   */
  apiUrl: string;
  /**
   * The WEB url for a GitHub instance. https://github.com/ for Github.com, https://github.company.com/ when using GitHub Enterprise.
   *
   */
  webUrl: string;
  allowedOrganizations: Array<string>;
  /**
   * Type of synchronization
   */
  provisioningType: 'JIT' | 'AUTO_PROVISIONING';
  /**
   * Allow user to sign up
   */
  allowUsersToSignUp?: boolean;
  /**
   * Change project visibility based on GitHub repository visibility.
   * If disabled, every provisioned project will be private in SonarQube and visible only to users with explicit GitHub permissions for the corresponding repository.
   * Changes take effect at the next synchronization.
   *
   */
  projectVisibility?: boolean;
  /**
   * Admin consent to synchronize permissions from GitHub
   */
  userConsentRequiredAfterUpgrade?: boolean;
};

export type GithubConfigurationResourceWritable = {
  enabled?: boolean;
  /**
   * GitHub Application id
   */
  applicationId?: string;
  synchronizeGroups?: boolean;
  /**
   * Url of GitHub instance for API connectivity (for instance https://api.github.com)
   */
  apiUrl?: string;
  /**
   * Url of GitHub instance for authentication (for instance https://github.com)
   */
  webUrl?: string;
  /**
   * GitHub organizations allowed to authenticate and provisioned
   */
  allowedOrganizations?: Array<string>;
  provisioningType?: 'JIT' | 'AUTO_PROVISIONING';
  allowUsersToSignUp?: boolean;
  projectVisibility?: boolean;
  userConsentRequiredAfterUpgrade?: boolean;
};

export type ParameterWritable = {
  key?: string;
  defaultValue?: string;
};

export type RuleDescriptionSectionRestResponseWritable = {
  [key: string]: unknown;
};

export type GroupRestResponseWritable = {
  name?: string;
  description?: string;
};

export type ModeResourceWritable = {
  mode: 'MQR' | 'STANDARD_EXPERIENCE';
};

export type DopSettingsResourceWritable = {
  /**
   * Supported DevOps Platform are: github, gitlab, azure, bitbucketcloud, bitbucket_server
   */
  type?: string;
  key?: string;
  url?: string;
  appId?: string;
};

export type GroupsMembershipSearchRestResponseWritable = {
  groupMemberships?: Array<unknown>;
  page?: PageRestResponse;
};

/**
 * Current page
 */
export type P2 = number;

/**
 * Page size. Must be greater than 0 and less or equal than 500
 */
export type Ps = bigint;

export type SearchData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Return active/inactive users
     */
    active?: boolean;
    /**
     * Return managed or non-managed users. Only available for managed instances, throws for non-managed instances
     */
    managed?: boolean;
    /**
     * Filter on login, name and email.
     * This parameter performs a partial match (contains), it is case insensitive.
     */
    q?: string;
    /**
     * Filter on externalIdentity.
     * This parameter perform a case-sensitive exact match
     */
    externalIdentity?: string;
    /**
     * Filter users based on the last connection date field. Only users who interacted with this instance at or after the date will be returned. The format must be ISO 8601 datetime format (YYYY-MM-DDThh:mm:sshhmm)
     */
    sonarQubeLastConnectionDateFrom?: string;
    /**
     * Filter users based on the last connection date field. Only users that never connected or who interacted with this instance at or before the date will be returned. The format must be ISO 8601 datetime format (YYYY-MM-DDThh:mm:sshhmm)
     */
    sonarQubeLastConnectionDateTo?: string;
    /**
     * Filter users based on the SonarLint last connection date field Only users who interacted with this instance using SonarLint at or after the date will be returned. The format must be ISO 8601 datetime format (YYYY-MM-DDThh:mm:sshhmm)
     */
    sonarLintLastConnectionDateFrom?: string;
    /**
     * Filter users based on the SonarLint last connection date field. Only users that never connected or who interacted with this instance using SonarLint at or before the date will be returned. The format must be ISO 8601 datetime format (YYYY-MM-DDThh:mm:sshhmm)
     */
    sonarLintLastConnectionDateTo?: string;
    /**
     * Filter users belonging to group. Only available for system administrators. Using != operator will exclude users from this group.
     */
    groupId?: string;
    /**
     * Number of results per page. A value of 0 will only return the pagination information.
     */
    pageSize?: number;
    /**
     * 1-based page index
     */
    pageIndex?: number;
  };
  url: '/v2/users-management/users';
};

export type SearchResponses = {
  /**
   * OK
   */
  200: UsersSearchRestResponse;
};

export type SearchResponse = SearchResponses[keyof SearchResponses];

export type CreateData = {
  body: UserCreateRestRequestWritable;
  path?: never;
  query?: never;
  url: '/v2/users-management/users';
};

export type CreateResponses = {
  /**
   * OK
   */
  200: UserRestResponseForAdmins;
};

export type CreateResponse = CreateResponses[keyof CreateResponses];

export type SearchEmailConfigurationsData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/system/email-configurations';
};

export type SearchEmailConfigurationsResponses = {
  /**
   * OK
   */
  200: EmailConfigurationSearchRestResponse;
};

export type SearchEmailConfigurationsResponse =
  SearchEmailConfigurationsResponses[keyof SearchEmailConfigurationsResponses];

export type CreateEmailConfigurationData = {
  body: EmailConfigurationCreateRestRequestWritable;
  path?: never;
  query?: never;
  url: '/v2/system/email-configurations';
};

export type CreateEmailConfigurationResponses = {
  /**
   * OK
   */
  200: EmailConfigurationResource;
};

export type CreateEmailConfigurationResponse =
  CreateEmailConfigurationResponses[keyof CreateEmailConfigurationResponses];

export type IndexData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * If provided, filter to the license profile that is used to analyze the project (if one exists).
     *
     */
    projectKey?: string;
  };
  url: '/v2/sca/license-profiles';
};

export type IndexResponses = {
  /**
   * OK
   */
  200: LicenseProfileIndexRestResponse;
};

export type IndexResponse = IndexResponses[keyof IndexResponses];

export type Create1Data = {
  body: LicenseProfilesCreateRestRequest;
  path?: never;
  query?: never;
  url: '/v2/sca/license-profiles';
};

export type Create1Responses = {
  /**
   * Created
   */
  201: LicenseProfileResource;
};

export type Create1Response = Create1Responses[keyof Create1Responses];

export type UpdateAssigneeData = {
  body: UpdateAssigneeRestRequest;
  path?: never;
  query?: never;
  url: '/v2/sca/issues-releases/update-assignee';
};

export type UpdateAssigneeResponses = {
  /**
   * OK
   */
  200: IssueReleaseDetailsResource;
};

export type UpdateAssigneeResponse =
  UpdateAssigneeResponses[keyof UpdateAssigneeResponses];

export type SetSeverityData = {
  body: IssueReleaseSetSeverityRestRequest;
  path?: never;
  query?: never;
  url: '/v2/sca/issues-releases/set-severity';
};

export type SetSeverityResponses = {
  /**
   * OK
   */
  200: IssueReleaseDetailsResource;
};

export type SetSeverityResponse =
  SetSeverityResponses[keyof SetSeverityResponses];

export type ClearSeverityWarningData = {
  body: IssueReleaseClearSeverityWarningRestRequest;
  path?: never;
  query?: never;
  url: '/v2/sca/issues-releases/clear-severity-warning';
};

export type ClearSeverityWarningResponses = {
  /**
   * OK
   */
  200: IssueReleaseDetailsResource;
};

export type ClearSeverityWarningResponse =
  ClearSeverityWarningResponses[keyof ClearSeverityWarningResponses];

export type TransitionIssueReleaseData = {
  body: IssueReleaseStatusTransitionRequest;
  path?: never;
  query?: never;
  url: '/v2/sca/issues-releases/change-status';
};

export type TransitionIssueReleaseResponses = {
  /**
   * OK
   */
  200: IssueReleaseDetailsResource;
};

export type TransitionIssueReleaseResponse =
  TransitionIssueReleaseResponses[keyof TransitionIssueReleaseResponses];

export type AddCommentData = {
  body: IssueReleaseAddCommentRestRequest;
  path?: never;
  query?: never;
  url: '/v2/sca/issues-releases/add-comment';
};

export type AddCommentResponses = {
  /**
   * OK
   */
  200: unknown;
};

export type BillAzureAccountData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/marketplace/azure/billing';
};

export type BillAzureAccountResponses = {
  /**
   * OK
   */
  200: AzureBillingRestResponse;
};

export type BillAzureAccountResponse =
  BillAzureAccountResponses[keyof BillAzureAccountResponses];

export type Data = {
  body?: never;
  path?: never;
  query: {
    sonarProjectId: string;
    resourceId: string;
    resourceType: 'SONAR_ISSUE' | 'DEPENDENCY_RISK';
  };
  url: '/v2/jira/work-items';
};

export type Responses = {
  /**
   * No Content
   */
  204: void;
};

export type Response = Responses[keyof Responses];

export type Data = {
  body?: never;
  path?: never;
  query: {
    sonarProjectId: string;
    resourceId: string;
    resourceType: 'SONAR_ISSUE' | 'DEPENDENCY_RISK';
  };
  url: '/v2/jira/work-items';
};

export type Responses = {
  /**
   * OK
   */
  200: JiraWorkItemResource;
};

export type Response = Responses[keyof Responses];

export type 1Data = {
  body: PostJiraWorkItemRequestResource;
  path?: never;
  query?: never;
  url: '/v2/jira/work-items';
};

export type 1Responses = {
  /**
   * Created
   */
  201: JiraWorkItemResource;
};

export type 1Response = 1Responses[keyof 1Responses];

export type 1Data = {
  body?: never;
  path?: never;
  query: {
    sonarProjectId: string;
  };
  url: '/v2/jira/project-bindings';
};

export type 1Responses = {
  /**
   * No Content
   */
  204: void;
};

export type 1Response = 1Responses[keyof 1Responses];

export type 2Data = {
  body?: never;
  path?: never;
  query: {
    sonarProjectId: string;
  };
  url: '/v2/jira/project-bindings';
};

export type 2Responses = {
  /**
   * OK
   */
  200: JiraProjectBindingResource;
};

export type 2Response = 2Responses[keyof 2Responses];

export type 4Data = {
  body: PatchJiraProjectBindingRequestResource;
  path?: never;
  query?: never;
  url: '/v2/jira/project-bindings';
};

export type 4Responses = {
  /**
   * OK
   */
  200: JiraProjectBindingResource;
};

export type 4Response = 4Responses[keyof 4Responses];

export type 3Data = {
  body: PostJiraProjectBindingRequestResource;
  path?: never;
  query?: never;
  url: '/v2/jira/project-bindings';
};

export type 3Responses = {
  /**
   * Created
   */
  201: JiraProjectBindingResource;
};

export type 3Response = 3Responses[keyof 3Responses];

export type 2Data = {
  body?: never;
  path?: never;
  query: {
    sonarOrganizationUuid: string;
  };
  url: '/v2/jira/organization-bindings';
};

export type 2Responses = {
  /**
   * No Content
   */
  204: void;
};

export type 2Response = 2Responses[keyof 2Responses];

export type 5Data = {
  body?: never;
  path?: never;
  query: {
    sonarOrganizationUuid: string;
  };
  url: '/v2/jira/organization-bindings';
};

export type 5Responses = {
  /**
   * OK
   */
  200: JiraOrganizationBindingResource;
};

export type 5Response = 5Responses[keyof 5Responses];

export type 7Data = {
  body: PatchJiraOrganizationBindingRequestResource;
  path?: never;
  query?: never;
  url: '/v2/jira/organization-bindings';
};

export type 7Responses = {
  /**
   * Created
   */
  201: JiraOrganizationBindingResource;
};

export type 7Response = 7Responses[keyof 7Responses];

export type 6Data = {
  body: PostJiraOrganizationBindingRequestResource;
  path?: never;
  query?: never;
  url: '/v2/jira/organization-bindings';
};

export type 6Responses = {
  /**
   * Created
   */
  201: PostJiraOrganizationBindingResponseResource;
};

export type 6Response = 6Responses[keyof 6Responses];

export type CreateUserBindingData = {
  body: UserBindingCreationRequest;
  path?: never;
  query?: never;
  url: '/v2/integrations/user-bindings';
};

export type CreateUserBindingErrors = {
  /**
   * Invalid request data
   */
  400: unknown;
  /**
   * Authentication required
   */
  401: unknown;
  /**
   * Insufficient permissions
   */
  403: unknown;
  /**
   * User binding already exists
   */
  409: unknown;
  /**
   * Internal server error
   */
  500: unknown;
};

export type CreateUserBindingResponses = {
  /**
   * User binding created successfully
   */
  201: UserBindingResponse;
};

export type CreateUserBindingResponse =
  CreateUserBindingResponses[keyof CreateUserBindingResponses];

export type HandleSlashCommandData = {
  body: string;
  path?: never;
  query?: never;
  url: '/v2/integrations/slack/slash-commands';
};

export type HandleSlashCommandResponses = {
  /**
   * OK
   */
  200: unknown;
};

export type HandleEventData = {
  body: string;
  path?: never;
  query?: never;
  url: '/v2/integrations/slack/events';
};

export type HandleEventResponses = {
  /**
   * OK
   */
  200: string;
};

export type HandleEventResponse =
  HandleEventResponses[keyof HandleEventResponses];

export type GetData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Integration type
     */
    integrationType: 'SLACK';
  };
  url: '/v2/integrations/integration-configurations';
};

export type GetResponses = {
  /**
   * OK
   */
  200: IntegrationConfigurationSearchResponse;
};

export type GetResponse = GetResponses[keyof GetResponses];

export type Create2Data = {
  body: IntegrationConfigurationPostRequest;
  path?: never;
  query?: never;
  url: '/v2/integrations/integration-configurations';
};

export type Create2Responses = {
  /**
   * Created
   */
  201: IntegrationConfigurationResponse;
};

export type Create2Response = Create2Responses[keyof Create2Responses];

export type CreateAwarenessBannerClickedData = {
  body: AwarenessBannerClickedRequest;
  path?: never;
  query?: never;
  url: '/v2/fix-suggestions/feature-enablements/awareness-banner-interactions';
};

export type CreateAwarenessBannerClickedResponses = {
  /**
   * OK
   */
  200: AwarenessBannerClickedResponse;
};

export type CreateAwarenessBannerClickedResponse =
  CreateAwarenessBannerClickedResponses[keyof CreateAwarenessBannerClickedResponses];

export type Create3Data = {
  body: FixSuggestionPostRequest;
  path?: never;
  query?: never;
  url: '/v2/fix-suggestions/ai-suggestions';
};

export type Create3Responses = {
  /**
   * OK
   */
  200: FixSuggestionResponse;
};

export type Create3Response = Create3Responses[keyof Create3Responses];

export type SetLicenseData = {
  body: LicenseRestRequest;
  path?: never;
  query?: never;
  url: '/v2/entitlements/online-activation';
};

export type SetLicenseResponses = {
  /**
   * OK
   */
  200: unknown;
};

export type DeactivateLicenseData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/entitlements/offline-deactivation';
};

export type DeactivateLicenseResponses = {
  /**
   * OK
   */
  200: Blob | File;
};

export type DeactivateLicenseResponse =
  DeactivateLicenseResponses[keyof DeactivateLicenseResponses];

export type RetrieveRequestFileData = {
  body?: never;
  headers: {
    /**
     * The unique license key associated with the license, in the format 'ABCD-EFGH-IJKL-MNOP'. Required in the 'License-Key' HTTP header for offline activation.
     */
    'License-Key': string;
  };
  path?: never;
  query?: never;
  url: '/v2/entitlements/offline-activation';
};

export type RetrieveRequestFileResponses = {
  /**
   * OK
   */
  200: Blob | File;
};

export type RetrieveRequestFileResponse =
  RetrieveRequestFileResponses[keyof RetrieveRequestFileResponses];

export type UploadLicenseData = {
  body: LicenseUploadActivationRequest;
  path?: never;
  query?: never;
  url: '/v2/entitlements/offline-activation';
};

export type UploadLicenseResponses = {
  /**
   * OK
   */
  200: unknown;
};

export type SetLegacyLicenseData = {
  body: LegacyLicenseRestRequest;
  path?: never;
  query?: never;
  url: '/v2/entitlements/legacy-activation';
};

export type SetLegacyLicenseResponses = {
  /**
   * OK
   */
  200: unknown;
};

export type Create4Data = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/dop-translation/gitlab-synchronization-runs';
};

export type Create4Responses = {
  /**
   * OK
   */
  200: GitlabSynchronizationRunResource;
};

export type Create4Response = Create4Responses[keyof Create4Responses];

export type FetchAllData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/dop-translation/gitlab-permission-mappings';
};

export type FetchAllResponses = {
  /**
   * OK
   */
  200: PermissionMappingsSearchRestResponse;
};

export type FetchAllResponse = FetchAllResponses[keyof FetchAllResponses];

export type CreateMappingData = {
  body: PermissionMappingsPostRequest;
  path?: never;
  query?: never;
  url: '/v2/dop-translation/gitlab-permission-mappings';
};

export type CreateMappingResponses = {
  /**
   * OK
   */
  200: PermissionMappingsResource;
};

export type CreateMappingResponse =
  CreateMappingResponses[keyof CreateMappingResponses];

export type SearchGitlabConfigurationData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/dop-translation/gitlab-configurations';
};

export type SearchGitlabConfigurationResponses = {
  /**
   * OK
   */
  200: GitlabConfigurationSearchRestResponse;
};

export type SearchGitlabConfigurationResponse =
  SearchGitlabConfigurationResponses[keyof SearchGitlabConfigurationResponses];

export type Create5Data = {
  body: GitlabConfigurationCreateRestRequestWritable;
  path?: never;
  query?: never;
  url: '/v2/dop-translation/gitlab-configurations';
};

export type Create5Responses = {
  /**
   * OK
   */
  200: GitlabConfigurationResource;
};

export type Create5Response = Create5Responses[keyof Create5Responses];

export type FetchAll1Data = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/dop-translation/github-permission-mappings';
};

export type FetchAll1Responses = {
  /**
   * OK
   */
  200: PermissionMappingsSearchRestResponse;
};

export type FetchAll1Response = FetchAll1Responses[keyof FetchAll1Responses];

export type CreateMapping1Data = {
  body: PermissionMappingsPostRequest;
  path?: never;
  query?: never;
  url: '/v2/dop-translation/github-permission-mappings';
};

export type CreateMapping1Responses = {
  /**
   * OK
   */
  200: PermissionMappingsResource;
};

export type CreateMapping1Response =
  CreateMapping1Responses[keyof CreateMapping1Responses];

export type SearchGithubConfigurationData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/dop-translation/github-configurations';
};

export type SearchGithubConfigurationResponses = {
  /**
   * OK
   */
  200: GithubConfigurationSearchRestResponse;
};

export type SearchGithubConfigurationResponse =
  SearchGithubConfigurationResponses[keyof SearchGithubConfigurationResponses];

export type CreateGithubConfigurationData = {
  body: GithubConfigurationCreateRestRequestWritable;
  path?: never;
  query?: never;
  url: '/v2/dop-translation/github-configurations';
};

export type CreateGithubConfigurationResponses = {
  /**
   * OK
   */
  200: GithubConfigurationResource;
};

export type CreateGithubConfigurationResponse =
  CreateGithubConfigurationResponses[keyof CreateGithubConfigurationResponses];

export type CreateBoundProjectData = {
  body: BoundProjectCreateRestRequest;
  path?: never;
  query?: never;
  url: '/v2/dop-translation/bound-projects';
};

export type CreateBoundProjectResponses = {
  /**
   * Created
   */
  201: BoundProjectCreateRestResponse;
};

export type CreateBoundProjectResponse =
  CreateBoundProjectResponses[keyof CreateBoundProjectResponses];

export type Create6Data = {
  body: RuleCreateRestRequest;
  path?: never;
  query?: never;
  url: '/v2/clean-code-policy/rules';
};

export type Create6Responses = {
  /**
   * OK
   */
  200: RuleRestResponse;
};

export type Create6Response = Create6Responses[keyof Create6Responses];

export type Search1Data = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Return managed or non-managed groups. Only available for managed instances, throws for non-managed instances
     */
    managed?: boolean;
    /**
     * Filter on name.
     * This parameter performs a partial match (contains), it is case insensitive.
     */
    q?: string;
    /**
     * Filter groups containing the user. Only available for system administrators. Using != operator will search for groups without the user.
     */
    userId?: string;
    /**
     * Number of results per page. A value of 0 will only return the pagination information.
     */
    pageSize?: number;
    /**
     * 1-based page index
     */
    pageIndex?: number;
  };
  url: '/v2/authorizations/groups';
};

export type Search1Responses = {
  /**
   * OK
   */
  200: GroupsSearchRestResponse;
};

export type Search1Response = Search1Responses[keyof Search1Responses];

export type Create7Data = {
  body: GroupCreateRestRequest;
  path?: never;
  query?: never;
  url: '/v2/authorizations/groups';
};

export type Create7Responses = {
  /**
   * Created
   */
  201: GroupRestResponse;
};

export type Create7Response = Create7Responses[keyof Create7Responses];

export type Search2Data = {
  body?: never;
  path?: never;
  query?: {
    /**
     * ID of the user for which to search groups. If not set, all groups are returned.
     */
    userId?: string;
    /**
     * ID of the group for which to search members. If not set, all groups are returned.
     */
    groupId?: string;
    /**
     * Number of results per page. A value of 0 will only return the pagination information.
     */
    pageSize?: number;
    /**
     * 1-based page index
     */
    pageIndex?: number;
  };
  url: '/v2/authorizations/group-memberships';
};

export type Search2Responses = {
  /**
   * OK
   */
  200: GroupsMembershipSearchRestResponse;
};

export type Search2Response = Search2Responses[keyof Search2Responses];

export type Create8Data = {
  body: GroupMembershipCreateRestRequest;
  path?: never;
  query?: never;
  url: '/v2/authorizations/group-memberships';
};

export type Create8Responses = {
  /**
   * Created
   */
  201: GroupMembershipRestResponse;
};

export type Create8Response = Create8Responses[keyof Create8Responses];

export type 8Data = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/atlassian/application-configuration';
};

export type 8Responses = {
  /**
   * OK
   */
  200: AtlassianAuthenticationDetailsResultResource;
};

export type 8Response = 8Responses[keyof 8Responses];

export type 9Data = {
  body: AtlassianAuthenticationDetailsResource;
  path?: never;
  query?: never;
  url: '/v2/atlassian/application-configuration';
};

export type 9Responses = {
  /**
   * OK
   */
  200: AtlassianAuthenticationDetailsResultResource;
};

export type 9Response = 9Responses[keyof 9Responses];

export type DeactivateData = {
  body?: never;
  path: {
    /**
     * The ID of the user to delete.
     */
    id: string;
  };
  query?: {
    /**
     * Anonymize user in addition to deactivating it.
     */
    anonymize?: boolean;
  };
  url: '/v2/users-management/users/{id}';
};

export type DeactivateResponses = {
  /**
   * No Content
   */
  204: void;
};

export type DeactivateResponse = DeactivateResponses[keyof DeactivateResponses];

export type FetchUserData = {
  body?: never;
  path: {
    /**
     * The id of the user to fetch.
     */
    id: string;
  };
  query?: never;
  url: '/v2/users-management/users/{id}';
};

export type FetchUserResponses = {
  /**
   * OK
   */
  200: UserRestResponseForAdmins;
};

export type FetchUserResponse = FetchUserResponses[keyof FetchUserResponses];

export type UpdateUserData = {
  body: UserUpdateRestRequest;
  path: {
    id: string;
  };
  query?: never;
  url: '/v2/users-management/users/{id}';
};

export type UpdateUserResponses = {
  /**
   * OK
   */
  200: UserRestResponseForAdmins;
};

export type UpdateUserResponse = UpdateUserResponses[keyof UpdateUserResponses];

export type DeleteEmailConfigurationData = {
  body?: never;
  path: {
    /**
     * The id of the configuration to delete.
     */
    id: string;
  };
  query?: never;
  url: '/v2/system/email-configurations/{id}';
};

export type DeleteEmailConfigurationResponses = {
  /**
   * No Content
   */
  204: void;
};

export type DeleteEmailConfigurationResponse =
  DeleteEmailConfigurationResponses[keyof DeleteEmailConfigurationResponses];

export type GetEmailConfigurationData = {
  body?: never;
  path: {
    /**
     * The id of the configuration to fetch.
     */
    id: string;
  };
  query?: never;
  url: '/v2/system/email-configurations/{id}';
};

export type GetEmailConfigurationResponses = {
  /**
   * OK
   */
  200: EmailConfigurationResource;
};

export type GetEmailConfigurationResponse =
  GetEmailConfigurationResponses[keyof GetEmailConfigurationResponses];

export type UpdateEmailConfigurationData = {
  body: EmailConfigurationUpdateRestRequest;
  path: {
    id: string;
  };
  query?: never;
  url: '/v2/system/email-configurations/{id}';
};

export type UpdateEmailConfigurationResponses = {
  /**
   * OK
   */
  200: EmailConfigurationResource;
};

export type UpdateEmailConfigurationResponse =
  UpdateEmailConfigurationResponses[keyof UpdateEmailConfigurationResponses];

export type DeleteData = {
  body?: never;
  path: {
    /**
     * The id of the license profile
     */
    'license-profile-key': string;
  };
  query?: never;
  url: '/v2/sca/license-profiles/{license-profile-key}';
};

export type DeleteResponses = {
  /**
   * No Content
   */
  204: void;
};

export type DeleteResponse = DeleteResponses[keyof DeleteResponses];

export type Get1Data = {
  body?: never;
  path: {
    /**
     * The license profile key.
     */
    'license-profile-key': string;
  };
  query?: never;
  url: '/v2/sca/license-profiles/{license-profile-key}';
};

export type Get1Responses = {
  /**
   * OK
   */
  200: LicenseProfileDetailsResource;
};

export type Get1Response = Get1Responses[keyof Get1Responses];

export type UpdateData = {
  body: LicenseProfilesUpdateRestRequest;
  path: {
    /**
     * The id of the license profile
     */
    'license-profile-key': string;
  };
  query?: never;
  url: '/v2/sca/license-profiles/{license-profile-key}';
};

export type UpdateResponses = {
  /**
   * OK
   */
  200: LicenseProfileResource;
};

export type UpdateResponse = UpdateResponses[keyof UpdateResponses];

export type PatchLicenseData = {
  body: LicensePolicyLicenseUpdateRestRequest;
  path: {
    /**
     * The license profile key.
     */
    'license-profile-key': string;
    /**
     * The license ID.
     */
    'license-policy-id': string;
  };
  query?: never;
  url: '/v2/sca/license-profiles/{license-profile-key}/licenses/{license-policy-id}';
};

export type PatchLicenseResponses = {
  /**
   * OK
   */
  200: LicensePolicyLicenseResource;
};

export type PatchLicenseResponse =
  PatchLicenseResponses[keyof PatchLicenseResponses];

export type PatchCategoryData = {
  body: LicenseProfileCategoryUpdateRestRequest;
  path: {
    /**
     * The license profile key.
     */
    'license-profile-key': string;
    /**
     * The category key.
     */
    'category-key':
      | 'UNKNOWN'
      | 'COPYLEFT_WEAK'
      | 'COPYLEFT_STRONG'
      | 'COPYLEFT_NETWORK'
      | 'COPYLEFT_MAXIMAL'
      | 'PERMISSIVE_STANDARD'
      | 'PERMISSIVE_AMATEUR';
  };
  query?: never;
  url: '/v2/sca/license-profiles/{license-profile-key}/categories/{category-key}';
};

export type PatchCategoryResponses = {
  /**
   * OK
   */
  200: LicenseProfileCategoryResource;
};

export type PatchCategoryResponse =
  PatchCategoryResponses[keyof PatchCategoryResponses];

export type Update1Data = {
  body: AssignedProjectsUpdateRestRequest;
  path?: never;
  query?: never;
  url: '/v2/sca/license-profiles/assigned-projects';
};

export type Update1Responses = {
  /**
   * The provided project has been assigned to the license profile.
   */
  200: LicenseProfileResource;
};

export type Update1Response = Update1Responses[keyof Update1Responses];

export type DeleteCommentData = {
  body?: never;
  path: {
    /**
     * The key of the (issue,release) pair.
     */
    key: string;
  };
  query: {
    /**
     * Issue release change key
     */
    issueReleaseChangeKey: string;
  };
  url: '/v2/sca/issues-releases/{key}/changelog';
};

export type DeleteCommentResponses = {
  /**
   * OK
   */
  200: unknown;
};

export type GetChangelogData = {
  body?: never;
  path: {
    /**
     * The key of the (issue,release) pair.
     */
    key: string;
  };
  query?: never;
  url: '/v2/sca/issues-releases/{key}/changelog';
};

export type GetChangelogResponses = {
  /**
   * OK
   */
  200: IssuesReleasesChangesRestResponse;
};

export type GetChangelogResponse =
  GetChangelogResponses[keyof GetChangelogResponses];

export type UpdateCommentData = {
  body: IssueReleaseUpdateCommentRestRequest;
  path: {
    /**
     * The key of the (issue,release) pair.
     */
    key: string;
  };
  query?: never;
  url: '/v2/sca/issues-releases/{key}/changelog';
};

export type UpdateCommentResponses = {
  /**
   * OK
   */
  200: unknown;
};

export type GetFeatureEnablementData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/sca/feature-enablements';
};

export type GetFeatureEnablementResponses = {
  /**
   * OK
   */
  200: FeatureEnablementResource;
};

export type GetFeatureEnablementResponse =
  GetFeatureEnablementResponses[keyof GetFeatureEnablementResponses];

export type UpdateFeatureEnablementData = {
  body: FeatureEnablementRequest;
  path?: never;
  query?: never;
  url: '/v2/sca/feature-enablements';
};

export type UpdateFeatureEnablementResponses = {
  /**
   * OK
   */
  200: FeatureEnablementResource;
};

export type UpdateFeatureEnablementResponse =
  UpdateFeatureEnablementResponses[keyof UpdateFeatureEnablementResponses];

export type 10Data = {
  body?: never;
  path?: never;
  query: {
    jiraProjectKey: string;
    sonarOrganizationUuid: string;
    sonarProjectId?: string;
    includeFields?: boolean;
  };
  url: '/v2/jira/work-types';
};

export type 10Responses = {
  /**
   * OK
   */
  200: Array<JiraWorkTypeResultResource>;
};

export type 10Response = 10Responses[keyof 10Responses];

export type 11Data = {
  body: JiraWorkTypesSelectionResource;
  path?: never;
  query?: never;
  url: '/v2/jira/work-types';
};

export type 11Responses = {
  /**
   * OK
   */
  200: unknown;
};

export type GetSandboxSettingsData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/issues/sandbox-settings';
};

export type GetSandboxSettingsResponses = {
  /**
   * OK
   */
  200: SandboxSettingsResource;
};

export type GetSandboxSettingsResponse =
  GetSandboxSettingsResponses[keyof GetSandboxSettingsResponses];

export type PatchSandboxSettingsData = {
  body: SandboxSettingsResource;
  path?: never;
  query?: never;
  url: '/v2/issues/sandbox-settings';
};

export type PatchSandboxSettingsResponses = {
  /**
   * OK
   */
  200: SandboxSettingsResource;
};

export type PatchSandboxSettingsResponse =
  PatchSandboxSettingsResponses[keyof PatchSandboxSettingsResponses];

export type GetProjectSandboxSettingsData = {
  body?: never;
  path: {
    projectKey: string;
  };
  query?: never;
  url: '/v2/issues/sandbox-settings/{projectKey}';
};

export type GetProjectSandboxSettingsResponses = {
  /**
   * OK
   */
  200: SandboxSettingsProjectResource;
};

export type GetProjectSandboxSettingsResponse =
  GetProjectSandboxSettingsResponses[keyof GetProjectSandboxSettingsResponses];

export type PatchProjectSandboxSettingsData = {
  body: SandboxSettingsProjectResource;
  path: {
    projectKey: string;
  };
  query?: never;
  url: '/v2/issues/sandbox-settings/{projectKey}';
};

export type PatchProjectSandboxSettingsResponses = {
  /**
   * OK
   */
  200: SandboxSettingsProjectResource;
};

export type PatchProjectSandboxSettingsResponse =
  PatchProjectSandboxSettingsResponses[keyof PatchProjectSandboxSettingsResponses];

export type Delete1Data = {
  body?: never;
  path: {
    /**
     * ID of the integration configuration
     */
    id: string;
  };
  query?: never;
  url: '/v2/integrations/integration-configurations/{id}';
};

export type Delete1Responses = {
  /**
   * No Content
   */
  204: void;
};

export type Delete1Response = Delete1Responses[keyof Delete1Responses];

export type Update2Data = {
  body: IntegrationConfigurationPatchRequest;
  path: {
    /**
     * ID of the integration configuration
     */
    id: string;
  };
  query?: never;
  url: '/v2/integrations/integration-configurations/{id}';
};

export type Update2Responses = {
  /**
   * OK
   */
  200: IntegrationConfigurationResponse;
};

export type Update2Response = Update2Responses[keyof Update2Responses];

export type GetFeatureEnablement1Data = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/fix-suggestions/feature-enablements';
};

export type GetFeatureEnablement1Responses = {
  /**
   * OK
   */
  200: FeatureEnablementResponse;
};

export type GetFeatureEnablement1Response =
  GetFeatureEnablement1Responses[keyof GetFeatureEnablement1Responses];

export type UpdateFeatureEnablement1Data = {
  body: FeatureEnablementRequest;
  path?: never;
  query?: never;
  url: '/v2/fix-suggestions/feature-enablements';
};

export type UpdateFeatureEnablement1Responses = {
  /**
   * No Content
   */
  204: void;
};

export type UpdateFeatureEnablement1Response =
  UpdateFeatureEnablement1Responses[keyof UpdateFeatureEnablement1Responses];

export type DeleteLicenseData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/entitlements/license';
};

export type DeleteLicenseResponses = {
  /**
   * OK
   */
  200: unknown;
};

export type GetLicenseData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/entitlements/license';
};

export type GetLicenseResponses = {
  /**
   * OK
   */
  200: LicenseRestResponse;
};

export type GetLicenseResponse = GetLicenseResponses[keyof GetLicenseResponses];

export type RefreshLicenseData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/entitlements/license';
};

export type RefreshLicenseResponses = {
  /**
   * OK
   */
  200: unknown;
};

export type DeleteMappingData = {
  body?: never;
  path: {
    /**
     * The name of the role to delete
     */
    role: string;
  };
  query?: never;
  url: '/v2/dop-translation/gitlab-permission-mappings/{role}';
};

export type DeleteMappingResponses = {
  /**
   * No Content
   */
  204: void;
};

export type DeleteMappingResponse =
  DeleteMappingResponses[keyof DeleteMappingResponses];

export type UpdateMappingData = {
  body: DevOpsPermissionMappingUpdateRequest;
  path: {
    /**
     * The name of the role to update
     */
    role: string;
  };
  query?: never;
  url: '/v2/dop-translation/gitlab-permission-mappings/{role}';
};

export type UpdateMappingResponses = {
  /**
   * OK
   */
  200: PermissionMappingsResource;
};

export type UpdateMappingResponse =
  UpdateMappingResponses[keyof UpdateMappingResponses];

export type DeleteGitlabConfigurationData = {
  body?: never;
  path: {
    /**
     * The id of the configuration to delete.
     */
    id: string;
  };
  query?: never;
  url: '/v2/dop-translation/gitlab-configurations/{id}';
};

export type DeleteGitlabConfigurationResponses = {
  /**
   * No Content
   */
  204: void;
};

export type DeleteGitlabConfigurationResponse =
  DeleteGitlabConfigurationResponses[keyof DeleteGitlabConfigurationResponses];

export type GetGitlabConfigurationData = {
  body?: never;
  path: {
    /**
     * The id of the configuration to fetch.
     */
    id: string;
  };
  query?: never;
  url: '/v2/dop-translation/gitlab-configurations/{id}';
};

export type GetGitlabConfigurationResponses = {
  /**
   * OK
   */
  200: GitlabConfigurationResource;
};

export type GetGitlabConfigurationResponse =
  GetGitlabConfigurationResponses[keyof GetGitlabConfigurationResponses];

export type UpdateGitlabConfigurationData = {
  body: GitlabConfigurationUpdateRestRequest;
  path: {
    id: string;
  };
  query?: never;
  url: '/v2/dop-translation/gitlab-configurations/{id}';
};

export type UpdateGitlabConfigurationResponses = {
  /**
   * OK
   */
  200: GitlabConfigurationResource;
};

export type UpdateGitlabConfigurationResponse =
  UpdateGitlabConfigurationResponses[keyof UpdateGitlabConfigurationResponses];

export type DeleteMapping1Data = {
  body?: never;
  path: {
    /**
     * The name of the role to delete
     */
    role: string;
  };
  query?: never;
  url: '/v2/dop-translation/github-permission-mappings/{role}';
};

export type DeleteMapping1Responses = {
  /**
   * No Content
   */
  204: void;
};

export type DeleteMapping1Response =
  DeleteMapping1Responses[keyof DeleteMapping1Responses];

export type UpdateMapping1Data = {
  body: DevOpsPermissionMappingUpdateRequest;
  path: {
    /**
     * The name of the role to update
     */
    role: string;
  };
  query?: never;
  url: '/v2/dop-translation/github-permission-mappings/{role}';
};

export type UpdateMapping1Responses = {
  /**
   * OK
   */
  200: PermissionMappingsResource;
};

export type UpdateMapping1Response =
  UpdateMapping1Responses[keyof UpdateMapping1Responses];

export type DeleteGithubConfigurationData = {
  body?: never;
  path: {
    /**
     * The id of the configuration to delete.
     */
    id: string;
  };
  query?: never;
  url: '/v2/dop-translation/github-configurations/{id}';
};

export type DeleteGithubConfigurationResponses = {
  /**
   * No Content
   */
  204: void;
};

export type DeleteGithubConfigurationResponse =
  DeleteGithubConfigurationResponses[keyof DeleteGithubConfigurationResponses];

export type GetGithubConfigurationData = {
  body?: never;
  path: {
    /**
     * The id of the configuration to fetch.
     */
    id: string;
  };
  query?: never;
  url: '/v2/dop-translation/github-configurations/{id}';
};

export type GetGithubConfigurationResponses = {
  /**
   * OK
   */
  200: GithubConfigurationResource;
};

export type GetGithubConfigurationResponse =
  GetGithubConfigurationResponses[keyof GetGithubConfigurationResponses];

export type UpdateGithubConfigurationData = {
  body: GithubConfigurationUpdateRestRequest;
  path: {
    id: string;
  };
  query?: never;
  url: '/v2/dop-translation/github-configurations/{id}';
};

export type UpdateGithubConfigurationResponses = {
  /**
   * OK
   */
  200: GithubConfigurationResource;
};

export type UpdateGithubConfigurationResponse =
  UpdateGithubConfigurationResponses[keyof UpdateGithubConfigurationResponses];

export type GetModeData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/clean-code-policy/mode';
};

export type GetModeResponses = {
  /**
   * OK
   */
  200: ModeResource;
};

export type GetModeResponse = GetModeResponses[keyof GetModeResponses];

export type PatchModeData = {
  body: ModeResourceWritable;
  path?: never;
  query?: never;
  url: '/v2/clean-code-policy/mode';
};

export type PatchModeResponses = {
  /**
   * OK
   */
  200: ModeResource;
};

export type PatchModeResponse = PatchModeResponses[keyof PatchModeResponses];

export type DeleteGroupData = {
  body?: never;
  path: {
    /**
     * The ID of the group to delete.
     */
    id: string;
  };
  query?: never;
  url: '/v2/authorizations/groups/{id}';
};

export type DeleteGroupResponses = {
  /**
   * No Content
   */
  204: void;
};

export type DeleteGroupResponse =
  DeleteGroupResponses[keyof DeleteGroupResponses];

export type FetchGroupData = {
  body?: never;
  path: {
    /**
     * The id of the group to fetch.
     */
    id: string;
  };
  query?: never;
  url: '/v2/authorizations/groups/{id}';
};

export type FetchGroupResponses = {
  /**
   * OK
   */
  200: GroupRestResponse;
};

export type FetchGroupResponse = FetchGroupResponses[keyof FetchGroupResponses];

export type UpdateGroupData = {
  body: GroupUpdateRestRequest;
  path: {
    id: string;
  };
  query?: never;
  url: '/v2/authorizations/groups/{id}';
};

export type UpdateGroupResponses = {
  /**
   * OK
   */
  200: GroupRestResponse;
};

export type UpdateGroupResponse =
  UpdateGroupResponses[keyof UpdateGroupResponses];

export type GetStatusData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/system/migrations-status';
};

export type GetStatusResponses = {
  /**
   * OK
   */
  200: DatabaseMigrationsResponse;
};

export type GetStatusResponse = GetStatusResponses[keyof GetStatusResponses];

export type LivenessCheckData = {
  body?: never;
  headers?: {
    /**
     * Passcode can be provided, see SonarQube documentation
     */
    'X-Sonar-Passcode'?: string;
  };
  path?: never;
  query?: never;
  url: '/v2/system/liveness';
};

export type LivenessCheckErrors = {
  /**
   * This SonarQube node is not alive and should be rescheduled
   */
  default: unknown;
};

export type LivenessCheckResponses = {
  /**
   * This SonarQube node is alive
   */
  204: void;
};

export type LivenessCheckResponse =
  LivenessCheckResponses[keyof LivenessCheckResponses];

export type GetHealthData = {
  body?: never;
  headers?: {
    'X-Sonar-Passcode'?: string;
  };
  path?: never;
  query?: never;
  url: '/v2/system/health';
};

export type GetHealthResponses = {
  /**
   * OK
   */
  200: Health;
};

export type GetHealthResponse = GetHealthResponses[keyof GetHealthResponses];

export type PerformSelfTestData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/sca/self-test';
};

export type PerformSelfTestResponses = {
  /**
   * OK
   */
  200: SelfTestResponse;
};

export type PerformSelfTestResponse =
  PerformSelfTestResponses[keyof PerformSelfTestResponses];

export type PerformSpringConfigurationSelfTestData = {
  body?: never;
  path?: never;
  query: {
    selfTestName: string;
  };
  url: '/v2/sca/self-test/spring-configuration';
};

export type PerformSpringConfigurationSelfTestResponses = {
  /**
   * OK
   */
  200: SelfTestSpringConfigurationResponse;
};

export type PerformSpringConfigurationSelfTestResponse =
  PerformSpringConfigurationSelfTestResponses[keyof PerformSpringConfigurationSelfTestResponses];

export type GenerateReportData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Key of the component (project, application, portfolio) to build report for
     */
    component: string;
    /**
     * Key of the branch to build report for
     */
    branch?: string;
    /**
     * Type of report to generate.
     * The `Accept` header sent by the client determines the format of the report.
     * Currently supported: cyclonedx (application/vnd.cyclonedx+json), cyclonedx (application/vnd.cyclonedx+xml),
     * spdx_23 (application/spdx+json), spdx_23 (application/spdx+xml),
     * spdx_30 (application/spdx+json)
     *
     */
    type: 'cyclonedx' | 'spdx_23' | 'spdx_30';
  };
  url: '/v2/sca/sbom-reports';
};

export type GenerateReportResponses = {
  /**
   * The desired report in the desired output format
   */
  200: string;
};

export type GenerateReportResponse =
  GenerateReportResponses[keyof GenerateReportResponses];

export type GetReportData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Key of the component (project, application, portfolio) to build report for
     */
    component: string;
    /**
     * Key of the branch to build report for
     */
    branch?: string;
    /**
     * Type of risk to filter the report by. If not provided, all risks types are included.
     */
    riskType?: 'VULNERABILITY' | 'PROHIBITED_LICENSE';
  };
  url: '/v2/sca/risk-reports';
};

export type GetReportResponses = {
  /**
   * The report in the desired output format
   */
  200: Array<RiskReportItem>;
};

export type GetReportResponse = GetReportResponses[keyof GetReportResponses];

export type Search3Data = {
  body?: never;
  path?: never;
  query: {
    /**
     * Key of the component (project, application, or portfolio) to fetch all dependencies from
     */
    projectKey: string;
    /**
     * Key of the branch to fetch all dependencies from. If not provided, the default branch will be used unless a pull request key is provided.
     */
    branchKey?: string;
    /**
     * Key of the pull request to fetch all dependencies from.
     */
    pullRequestKey?: string;
    /**
     * Filter on the direct attribute. TRUE stands for direct dependencies, FALSE for transitive dependencies.
     */
    direct?: boolean;
    /**
     * Filter on the newlyIntroduced attribute. TRUE stands for only releases introduced vs. the target branch, FALSE for releases shared with target.
     */
    newlyIntroduced?: boolean;
    /**
     * Filter on the productionScope attribute. TRUE stands for only production dependencies, FALSE for only not in production. If a release is both, it matches both.
     */
    productionScope?: boolean;
    /**
     * Filter on the package manager
     */
    packageManagers?: Array<string>;
    /**
     * Filter on the package name. This parameter performs a partial match (contains and case insensitive) on the package name.
     */
    q?: string;
    /**
     * Number of results per page. A value of 0 will only return the pagination information.
     */
    pageSize?: number;
    /**
     * 1-based page index
     */
    pageIndex?: number;
  };
  url: '/v2/sca/releases';
};

export type Search3Responses = {
  /**
   * OK
   */
  200: ReleasesSearchRestResponse;
};

export type Search3Response = Search3Responses[keyof Search3Responses];

export type FetchReleaseData = {
  body?: never;
  path: {
    /**
     * The key of the release to fetch.
     */
    key: string;
  };
  query?: never;
  url: '/v2/sca/releases/{key}';
};

export type FetchReleaseResponses = {
  /**
   * OK
   */
  200: ReleaseDetailResource;
};

export type FetchReleaseResponse =
  FetchReleaseResponses[keyof FetchReleaseResponses];

export type Index1Data = {
  body?: never;
  path?: never;
  query: {
    /**
     * The key of the license profile whose assignable projects should be retrieved.
     *
     */
    licenseProfileUuid: string;
    /**
     *   Providing this parameter filters by whether projects are assigned to the license profile or not.
     * Omitting this parameter includes all projects which can be assigned to the license profile,
     * regardless of whether they are already assigned to the license profile.
     *
     */
    assignedToLicenseProfile?: boolean;
    /**
     *   Providing this parameter performs a partial match (contains and case insensitive) on the project name.
     *
     */
    q?: string;
    /**
     * Number of results per page. A value of 0 will only return the pagination information.
     */
    pageSize?: number;
    /**
     * 1-based page index
     */
    pageIndex?: number;
  };
  url: '/v2/sca/license-profiles/assignable-projects';
};

export type Index1Responses = {
  /**
   * OK
   */
  200: AssignableProjectsIndexRestResponse;
};

export type Index1Response = Index1Responses[keyof Index1Responses];

export type Search4Data = {
  body?: never;
  path?: never;
  query: {
    /**
     * Key of the component (project, application, portfolio) to fetch all dependency risks from.
     */
    projectKey: string;
    /**
     * Key of the branch to fetch all dependency risks from. If not provided, the default branch will be used unless a pull request key is provided.
     */
    branchKey?: string;
    /**
     * Key of the pull request to fetch all dependency risks from.
     */
    pullRequestKey?: string;
    /**
     * Sort order
     */
    sort?:
      | '+identity'
      | '-identity'
      | '+severity'
      | '-severity'
      | '+cvssScore'
      | '-cvssScore';
    /**
     * Filter on the package manager
     */
    packageManagers?: Array<string>;
    /**
     * Filter on the issue type
     */
    types?: Array<string>;
    /**
     * Filter on the quality domain
     */
    qualities?: Array<string>;
    /**
     * Filter on the severity
     */
    severities?: Array<string>;
    /**
     * Filter on the status
     */
    statuses?: Array<string>;
    /**
     * Filter on the package name. This parameter performs a partial match (contains and case insensitive) on the package name.
     */
    packageName?: string;
    /**
     * Filter on the vulnerability ID. This parameter performs a partial match (contains and case insensitive) on the vulnerability ID.
     */
    vulnerabilityId?: string;
    /**
     * Filter on the isNew attribute. TRUE stands for only releases introduced vs. the target branch, FALSE for releases shared with target.
     */
    newlyIntroduced?: boolean;
    /**
     * Filter on the direct attribute. TRUE stands for only direct dependencies, FALSE for only transitive. If a release is both, it matches both.
     */
    direct?: boolean;
    /**
     * Filter on the productionScope attribute. TRUE stands for only production dependencies, FALSE for only not in production. If a release is both, it matches both.
     */
    productionScope?: boolean;
    /**
     * Filter on assignee logins.
     */
    assignees?: Array<string>;
    /**
     * Filter on project keys.
     */
    projects?: Array<string>;
    /**
     * Filter on whether the issue is assigned or not.
     */
    assigned?: boolean;
    /**
     * Number of results per page. A value of 0 will only return the pagination information.
     */
    pageSize?: number;
    /**
     * 1-based page index
     */
    pageIndex?: number;
  };
  url: '/v2/sca/issues-releases';
};

export type Search4Responses = {
  /**
   * OK
   */
  200: IssuesReleasesSearchRestResponse;
};

export type Search4Response = Search4Responses[keyof Search4Responses];

export type FetchIssueReleaseData = {
  body?: never;
  path: {
    /**
     * The key of the issue,release pair to fetch.
     */
    key: string;
  };
  query?: never;
  url: '/v2/sca/issues-releases/{key}';
};

export type FetchIssueReleaseResponses = {
  /**
   * OK
   */
  200: IssueReleaseDetailsResource;
};

export type FetchIssueReleaseResponse =
  FetchIssueReleaseResponses[keyof FetchIssueReleaseResponses];

export type GetAllAssigneesData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Key of the project to fetch all assignee users from.
     */
    projectKey: string;
    /**
     * Key of the branch to fetch all assignee users from. If not provided, the default branch will be used unless a pull request key is provided.
     */
    branchKey?: string;
    /**
     * Key of the pull request to fetch all assignee users from.
     */
    pullRequestKey?: string;
  };
  url: '/v2/sca/issues-releases/all-assignees';
};

export type GetAllAssigneesResponses = {
  /**
   * OK
   */
  200: Array<UserResource>;
};

export type GetAllAssigneesResponse =
  GetAllAssigneesResponses[keyof GetAllAssigneesResponses];

export type GetFeatureEnabledData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/sca/enabled';
};

export type GetFeatureEnabledResponses = {
  /**
   * OK
   */
  200: ScaFeatureEnabledResource;
};

export type GetFeatureEnabledResponse =
  GetFeatureEnabledResponses[keyof GetFeatureEnabledResponses];

export type GetFeatureEnabled1Data = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/sca/feature-enabled';
};

export type GetFeatureEnabled1Responses = {
  /**
   * OK
   */
  200: ScaFeatureEnabledResource;
};

export type GetFeatureEnabled1Response =
  GetFeatureEnabled1Responses[keyof GetFeatureEnabled1Responses];

export type GetScaClisMetadataData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Filter by operating system
     */
    os?: 'windows' | 'linux' | 'macos';
    /**
     * Filter by CPU architecture
     */
    arch?: 'x64' | 'aarch64';
  };
  url: '/v2/sca/clis';
};

export type GetScaClisMetadataResponses = {
  /**
   * OK
   */
  200: Array<ScaCliInfoRestResponse>;
};

export type GetScaClisMetadataResponse =
  GetScaClisMetadataResponses[keyof GetScaClisMetadataResponses];

export type DownloadScaCliData = {
  body?: never;
  path: {
    /**
     * The ID of the SCA CLI download
     */
    id: string;
  };
  query?: never;
  url: '/v2/sca/clis/{id}';
};

export type DownloadScaCliResponses = {
  /**
   * OK
   */
  200: ScaCliInfoRestResponse;
};

export type DownloadScaCliResponse =
  DownloadScaCliResponses[keyof DownloadScaCliResponses];

export type FetchAnalysisData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Key of the project to fetch analysis status from
     */
    projectKey: string;
    /**
     * Key of the branch to fetch analysis status from. If not provided, the default branch will be used unless a pull request key is provided.
     */
    branchKey?: string;
    /**
     * Key of the pull request to fetch analysis status from.
     */
    pullRequestKey?: string;
  };
  url: '/v2/sca/analyses';
};

export type FetchAnalysisResponses = {
  /**
   * OK
   */
  200: AnalysisResource;
};

export type FetchAnalysisResponse =
  FetchAnalysisResponses[keyof FetchAnalysisResponses];

export type 12Data = {
  body?: never;
  path?: never;
  query: {
    sonarProjectId: string;
  };
  url: '/v2/jira/user-actions';
};

export type 12Responses = {
  /**
   * OK
   */
  200: Array<string>;
};

export type 12Response = 12Responses[keyof 12Responses];

export type 13Data = {
  body?: never;
  path?: never;
  query: {
    sonarOrganizationUuid: string;
  };
  url: '/v2/jira/projects';
};

export type 13Responses = {
  /**
   * OK
   */
  200: Array<JiraProjectResultResource>;
};

export type 13Response = 13Responses[keyof 13Responses];

export type 14Data = {
  body?: never;
  path: {
    sonarProjectId: string;
  };
  query?: never;
  url: '/v2/jira/linked-issues-count/{sonarProjectId}';
};

export type 14Responses = {
  /**
   * OK
   */
  200: LinkedIssuesCountResource;
};

export type 14Response = 14Responses[keyof 14Responses];

export type GetUserBindingData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/integrations/user-bindings/{id}';
};

export type GetUserBindingErrors = {
  /**
   * Authentication required
   */
  401: unknown;
  /**
   * Insufficient permissions
   */
  403: unknown;
  /**
   * User binding not found
   */
  404: unknown;
  /**
   * Internal server error
   */
  500: unknown;
};

export type GetUserBindingResponses = {
  /**
   * User binding retrieved successfully
   */
  200: UserBindingResponse;
};

export type GetUserBindingResponse =
  GetUserBindingResponses[keyof GetUserBindingResponses];

export type SupportedRulesData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/fix-suggestions/supported-rules';
};

export type SupportedRulesResponses = {
  /**
   * OK
   */
  200: SupportedRulesDto;
};

export type SupportedRulesResponse =
  SupportedRulesResponses[keyof SupportedRulesResponses];

export type GetLlmProvidersData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/fix-suggestions/supported-llm-providers';
};

export type GetLlmProvidersResponses = {
  /**
   * OK
   */
  200: Array<LlmProviderResponseDto>;
};

export type GetLlmProvidersResponse =
  GetLlmProvidersResponses[keyof GetLlmProvidersResponses];

export type Get2Data = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/fix-suggestions/service-info';
};

export type Get2Responses = {
  /**
   * OK
   */
  200: ServiceInfo;
};

export type Get2Response = Get2Responses[keyof Get2Responses];

export type Get3Data = {
  body?: never;
  path: {
    issueId: string;
  };
  query?: never;
  url: '/v2/fix-suggestions/issues/{issueId}';
};

export type Get3Responses = {
  /**
   * OK
   */
  200: FixSuggestionIssueResponse;
};

export type Get3Response = Get3Responses[keyof Get3Responses];

export type GetPurchasableFeaturesData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/entitlements/purchasable-features';
};

export type GetPurchasableFeaturesResponses = {
  /**
   * OK
   */
  200: Array<PurchasableFeatureRestResponse>;
};

export type GetPurchasableFeaturesResponse =
  GetPurchasableFeaturesResponses[keyof GetPurchasableFeaturesResponses];

export type GetProjectBindingByProjectIdData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Filter on the repository name.
     * This parameter performs an exact, case insensitive, match.
     *
     */
    repository?: string;
    /**
     * Filter on the DevOps Platform setting id.
     */
    dopSettingId?: string;
    /**
     * Filter on the repository URL.
     * This parameter can be in different formats, the traditional URL or the git remote URL (https or ssh).
     *
     */
    repositoryUrl?: string;
    /**
     * Number of results per page. A value of 0 will only return the pagination information.
     */
    pageSize?: number;
    /**
     * 1-based page index
     */
    pageIndex?: number;
  };
  url: '/v2/dop-translation/project-bindings';
};

export type GetProjectBindingByProjectIdResponses = {
  /**
   * OK
   */
  200: ProjectBindingsSearchRestResponse;
};

export type GetProjectBindingByProjectIdResponse =
  GetProjectBindingByProjectIdResponses[keyof GetProjectBindingByProjectIdResponses];

export type GetProjectBindingData = {
  body?: never;
  path: {
    /**
     * The id of the project-bindings to fetch.
     */
    id: string;
  };
  query?: never;
  url: '/v2/dop-translation/project-bindings/{id}';
};

export type GetProjectBindingResponses = {
  /**
   * OK
   */
  200: ProjectBinding;
};

export type GetProjectBindingResponse =
  GetProjectBindingResponses[keyof GetProjectBindingResponses];

export type FetchAllDopSettingsData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/dop-translation/dop-settings';
};

export type FetchAllDopSettingsResponses = {
  /**
   * OK
   */
  200: DopSettingsRestResponse;
};

export type FetchAllDopSettingsResponse =
  FetchAllDopSettingsResponses[keyof FetchAllDopSettingsResponses];

export type 15Data = {
  body?: never;
  path?: never;
  query: {
    sonarOrganizationKey: string;
    sonarOrganizationUuid: string;
  };
  url: '/v2/atlassian/auth-url';
};

export type 15Responses = {
  /**
   * OK
   */
  200: string;
};

export type 15Response = 15Responses[keyof 15Responses];

export type 16Data = {
  body?: never;
  path?: never;
  query: {
    /**
     * The key of the project.
     */
    projectKey: string;
    /**
     * The key of the branch.
     */
    branchKey: string;
  };
  url: '/v2/architecture/graphs';
};

export type 16Responses = {
  /**
   * OK
   */
  200: P;
};

export type 16Response = 16Responses[keyof 16Responses];

export type 17Data = {
  body?: never;
  path: {
    /**
     * id of the graph data.
     */
    id: string;
  };
  query?: never;
  url: '/v2/architecture/graphs/{id}';
};

export type 17Responses = {
  /**
   * OK
   */
  200: string;
};

export type 17Response = 17Responses[keyof 17Responses];

export type 18Data = {
  body?: never;
  path?: never;
  query: {
    /**
     * The key of the project.
     */
    projectKey: string;
    /**
     * The key of the branch.
     */
    branchKey: string;
    /**
     * The source that produced this graph. eg. java, python, js, etc.
     */
    source: string;
  };
  url: '/v2/architecture/file-graph';
};

export type 18Responses = {
  /**
   * OK
   */
  200: string;
};

export type 18Response = 18Responses[keyof 18Responses];

export type GetVersionData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/analysis/version';
};

export type GetVersionResponses = {
  /**
   * OK
   */
  200: string;
};

export type GetVersionResponse = GetVersionResponses[keyof GetVersionResponses];

export type GetJresMetadataData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Filter the JRE by operating system. Accepted values are 'windows', 'linux', 'macos', 'alpine' (case-insensitive), with some aliases
     */
    os?: string;
    /**
     * Filter the JRE by CPU architecture. Accepted values are 'x64' and 'aarch64' (case-insensitive), with some aliases.
     */
    arch?: string;
  };
  url: '/v2/analysis/jres';
};

export type GetJresMetadataResponses = {
  /**
   * OK
   */
  200: Array<JreInfoRestResponse>;
};

export type GetJresMetadataResponse =
  GetJresMetadataResponses[keyof GetJresMetadataResponses];

export type DownloadJreData = {
  body?: never;
  path: {
    /**
     * The ID of the JRE
     */
    id: string;
  };
  query?: never;
  url: '/v2/analysis/jres/{id}';
};

export type DownloadJreResponses = {
  /**
   * OK
   */
  200: JreInfoRestResponse;
};

export type DownloadJreResponse =
  DownloadJreResponses[keyof DownloadJreResponses];

export type DownloadScannerEngineData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/v2/analysis/engine';
};

export type DownloadScannerEngineResponses = {
  /**
   * OK
   */
  200: EngineInfoRestResponse;
};

export type DownloadScannerEngineResponse =
  DownloadScannerEngineResponses[keyof DownloadScannerEngineResponses];

export type GetActiveRulesData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Project Key
     */
    projectKey: string;
  };
  url: '/v2/analysis/active_rules';
};

export type GetActiveRulesResponses = {
  /**
   * OK
   */
  200: Array<ActiveRule>;
};

export type GetActiveRulesResponse =
  GetActiveRulesResponses[keyof GetActiveRulesResponses];

export type Delete2Data = {
  body?: never;
  path: {
    'project-key': string;
  };
  query?: never;
  url: '/v2/sca/license-profiles/assigned-projects/{project-key}';
};

export type Delete2Responses = {
  /**
   * No Content
   */
  204: void;
};

export type Delete2Response = Delete2Responses[keyof Delete2Responses];

export type Delete3Data = {
  body?: never;
  path: {
    /**
     * The ID of the group membership to delete.
     */
    id: string;
  };
  query?: never;
  url: '/v2/authorizations/group-memberships/{id}';
};

export type Delete3Responses = {
  /**
   * No Content
   */
  204: void;
};

export type Delete3Response = Delete3Responses[keyof Delete3Responses];

export type SearchIssuesData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Page size. Must be greater than 0 and less or equal than 500
     */
    ps?: bigint;
    /**
     * Current page
     */
    p?: number;
    /**
     * Comma-separated list of component keys. Retrieve issues associated with the specified components and their descendants.
     */
    componentKeys?: string;
    /**
     * Comma-separated list of project keys. Retrieve issues associated with the specified projects.
     */
    projectKeys?: string;
    /**
     * Comma-separated list of severities (INFO, MINOR, MAJOR, CRITICAL, BLOCKER).
     */
    severities?: string;
    /**
     * Comma-separated list of assignee logins. The value '__me__' can be used as a placeholder for user who performs the request
     */
    assignees?: string;
    /**
     * Comma-separated list of issue types (CODE_SMELL, BUG, VULNERABILITY).
     */
    types?: string;
    /**
     * Comma-separated list of statuses (OPEN, CONFIRMED, REOPENED, RESOLVED, CLOSED).
     */
    statuses?: string;
    /**
     * Comma-separated list of resolutions (FALSE-POSITIVE, WONTFIX, FIXED, REMOVED).
     */
    resolutions?: string;
    /**
     * Sort field
     */
    s?:
      | 'HOTSPOTS'
      | 'FILE_LINE'
      | 'STATUS'
      | 'SEVERITY'
      | 'CLOSE_DATE'
      | 'CREATION_DATE'
      | 'UPDATE_DATE';
    /**
     * Ascending sort. Default is false (descending).
     */
    asc?: boolean;
    /**
     * To match resolved or unresolved issues
     */
    resolved?: boolean;
    /**
     * Comma-separated list of rule keys.
     */
    rules?: string;
    /**
     * Comma-separated list of tags.
     */
    tags?: string;
    /**
     * Comma-separated list of SCM accounts. To set several values, the parameter must be called once for each value.
     */
    authors?: string;
    /**
     * Filter issues created after the given date (format YYYY-MM-DD or datetime ISO format).
     */
    createdAfter?: Date;
    /**
     * Filter issues created before the given date (format YYYY-MM-DD or datetime ISO format).
     */
    createdBefore?: Date;
    /**
     * Filter issues created at a specific date (format YYYY-MM-DD or datetime ISO format).
     */
    createdAt?: Date;
    /**
     * Filter issues created during a time span before now (e.g. 1m, 1h, 1d, 1w, 1y).
     */
    createdInLast?: string;
    /**
     * Comma-separated list of language keys.
     */
    languages?: string;
    /**
     * Comma-separated list of facets to include in the response.
     */
    facets?: string;
    /**
     * Comma-separated list of the optional fields to be returned in response. Action plans are dropped in 5.5, it is not returned in the response.
     */
    additionalFields?: string;
  };
  url: '/issues/search';
};

export type SearchIssuesErrors = {
  /**
   * The server could not understand the request due to invalid syntax. The client should modify the request and try again.
   */
  400: {
    errors?: Array<{
      message: string;
    }>;
    message: string;
  };
  /**
   * Authentication is required to access the requested resource. The client must include the appropriate credentials.
   */
  401: {
    message: string;
  };
  /**
   * Forbidden - The user does not have the required permissions
   */
  403: unknown;
  /**
   * Not found - The requested resource does not exist
   */
  404: unknown;
  /**
   * Internal server error
   */
  500: unknown;
  /**
   * The server is currently unable to handle the request due to a temporary overload or scheduled maintenance. Try again later.
   */
  503: {
    message: string;
    retryAfter?: number;
  };
};

export type SearchIssuesError = SearchIssuesErrors[keyof SearchIssuesErrors];

export type SearchIssuesResponses = {
  /**
   * The request was successful, and the server has returned the requested resource in the response body.
   */
  200: IssueSearchResponse;
};

export type SearchIssuesResponse =
  SearchIssuesResponses[keyof SearchIssuesResponses];

export type SearchProjectsData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Filter the projects for which the last analysis of all branches are older than the given date (exclusive).
     * Either a date (server timezone) or datetime can be provided.
     */
    analyzedBefore?: string;
    /**
     * 1-based page number
     */
    p?: number;
    /**
     * Limit search to:
     * component names that contain the supplied string
     * component keys that contain the supplied string
     */
    q?: string;
    /**
     * Filter the projects that are provisioned
     */
    onProvisionedOnly?: boolean;
    /**
     * Comma-separated list of project keys
     */
    projects?: string;
    /**
     * Page size. Must be greater than 0 and less or equal than 500
     */
    ps?: number;
    /**
     * Comma-separated list of component qualifiers. Filter the results with the specified qualifiers
     */
    qualifiers?: string;
  };
  url: '/projects/search';
};

export type SearchProjectsErrors = {
  /**
   * Authentication is required to access the requested resource. The client must include the appropriate credentials.
   */
  401: {
    message: string;
  };
};

export type SearchProjectsError =
  SearchProjectsErrors[keyof SearchProjectsErrors];

export type SearchProjectsResponses = {
  /**
   * The request was successful, and the server has returned the requested resource in the response body.
   */
  200: ProjectSearchResponse;
};

export type SearchProjectsResponse =
  SearchProjectsResponses[keyof SearchProjectsResponses];

export type ComponentData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Comma-separated list of additional fields that can be returned in the response.
     */
    additionalFields?: 'metrics' | 'period';
    /**
     * Branch key. Not available in the community edition.
     */
    branch?: string;
    /**
     * Component key
     */
    component: string;
    /**
     * Comma-separated list of metric keys
     */
    metricKeys:
      | 'accepted_issues'
      | 'new_software_quality_maintainability_remediation_effort'
      | 'new_technical_debt'
      | 'high_impact_accepted_issues'
      | 'blocker_violations'
      | 'software_quality_blocker_issues'
      | 'bugs'
      | 'classes'
      | 'code_smells'
      | 'cognitive_complexity'
      | 'comment_lines'
      | 'comment_lines_density'
      | 'branch_coverage'
      | 'new_branch_coverage'
      | 'conditions_to_cover'
      | 'new_conditions_to_cover'
      | 'confirmed_issues'
      | 'coverage'
      | 'new_coverage'
      | 'critical_violations'
      | 'complexity'
      | 'duplicated_blocks'
      | 'new_duplicated_blocks'
      | 'duplicated_files'
      | 'duplicated_lines'
      | 'duplicated_lines_density'
      | 'new_duplicated_lines_density'
      | 'new_duplicated_lines'
      | 'effort_to_reach_software_quality_maintainability_rating_a'
      | 'effort_to_reach_maintainability_rating_a'
      | 'false_positive_issues'
      | 'files'
      | 'functions'
      | 'generated_lines'
      | 'generated_ncloc'
      | 'software_quality_high_issues'
      | 'info_violations'
      | 'software_quality_info_issues'
      | 'violations'
      | 'prioritized_rule_issues'
      | 'line_coverage'
      | 'new_line_coverage'
      | 'lines'
      | 'ncloc'
      | 'lines_to_cover'
      | 'new_lines_to_cover'
      | 'software_quality_low_issues'
      | 'software_quality_maintainability_issues'
      | 'sqale_rating'
      | 'software_quality_maintainability_rating'
      | 'new_maintainability_rating'
      | 'new_software_quality_maintainability_rating'
      | 'major_violations'
      | 'software_quality_medium_issues'
      | 'minor_violations'
      | 'new_accepted_issues'
      | 'new_blocker_violations'
      | 'new_software_quality_blocker_issues'
      | 'new_bugs'
      | 'new_code_smells'
      | 'new_critical_violations'
      | 'new_software_quality_high_issues'
      | 'new_info_violations'
      | 'new_software_quality_info_issues'
      | 'new_violations'
      | 'new_lines'
      | 'new_software_quality_low_issues'
      | 'new_software_quality_maintainability_issues'
      | 'new_major_violations'
      | 'new_software_quality_medium_issues'
      | 'new_minor_violations'
      | 'new_software_quality_reliability_issues'
      | 'new_security_hotspots'
      | 'new_software_quality_security_issues'
      | 'new_vulnerabilities'
      | 'open_issues'
      | 'projects'
      | 'alert_status'
      | 'releasability_rating'
      | 'software_quality_reliability_issues'
      | 'reliability_rating'
      | 'software_quality_reliability_rating'
      | 'new_software_quality_reliability_rating'
      | 'new_reliability_rating'
      | 'software_quality_reliability_remediation_effort'
      | 'reliability_remediation_effort'
      | 'new_reliability_remediation_effort'
      | 'new_software_quality_reliability_remediation_effort'
      | 'reopened_issues'
      | 'security_hotspots'
      | 'security_hotspots_reviewed'
      | 'new_security_hotspots_reviewed'
      | 'software_quality_security_issues'
      | 'security_rating'
      | 'software_quality_security_rating'
      | 'new_software_quality_security_rating'
      | 'new_security_rating'
      | 'security_remediation_effort'
      | 'software_quality_security_remediation_effort'
      | 'new_software_quality_security_remediation_effort'
      | 'new_security_remediation_effort'
      | 'security_review_rating'
      | 'new_security_review_rating'
      | 'skipped_tests'
      | 'statements'
      | 'sqale_index'
      | 'software_quality_maintainability_remediation_effort'
      | 'sqale_debt_ratio'
      | 'software_quality_maintainability_debt_ratio'
      | 'new_software_quality_maintainability_debt_ratio'
      | 'new_sqale_debt_ratio'
      | 'uncovered_conditions'
      | 'new_uncovered_conditions'
      | 'uncovered_lines'
      | 'new_uncovered_lines'
      | 'test_execution_time'
      | 'test_errors'
      | 'test_failures'
      | 'tests'
      | 'test_success_density'
      | 'vulnerabilities';
    /**
     * Pull request id. Not available in the community edition.
     */
    pullRequest: string;
  };
  url: '/measures/component';
};

export type ComponentErrors = {
  /**
   * Authentication is required to access the requested resource. The client must include the appropriate credentials.
   */
  401: {
    message: string;
  };
  /**
   * The server understood the request, but refuses to authorize it. Ensure the client has appropriate permissions.
   */
  403: {
    message: string;
  };
};

export type ComponentError = ComponentErrors[keyof ComponentErrors];

export type ComponentResponses = {
  /**
   * The request was successful, and the server has returned the requested resource in the response body.
   */
  200: MeasureComponentResponse;
};

export type ComponentResponse = ComponentResponses[keyof ComponentResponses];

export type AddPermissionToAuserData = {
  body?: never;
  path?: never;
  query: {
    /**
     * User login
     */
    login: string;
    /**
     * The permission you would like to grant to the user
     *
     * Possible values for global permissions: admin, gateadmin, profileadmin, provisioning, scan, applicationcreator, portfoliocreator
     *
     * Possible values for project permissions admin, codeviewer, issueadmin, securityhotspotadmin, scan, user
     */
    permission: string;
    /**
     * Project id
     */
    projectId?: string;
    /**
     * Project key
     */
    projectKey?: string;
  };
  url: '/permissions/add_user';
};

export type AddPermissionToAuserResponses = {
  /**
   * The request was successful, and the server has returned the requested resource in the response body.
   */
  200: {
    data: {
      [key: string]: unknown;
    };
  };
};

export type AddPermissionToAuserResponse =
  AddPermissionToAuserResponses[keyof AddPermissionToAuserResponses];

export type AddAPermissionToAGroupData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Group name or 'anyone' (case insensitive)
     */
    groupName: string;
    /**
     * The permission you would like to grant to the group.
     *
     * Possible values for global permissions: admin, gateadmin, profileadmin, provisioning, scan, applicationcreator, portfoliocreator
     *
     * Possible values for project permissions admin, codeviewer, issueadmin, securityhotspotadmin, scan, user
     */
    permission: string;
    /**
     * Project id
     */
    projectId?: string;
    /**
     * Project key
     */
    projectKey?: string;
  };
  url: '/permissions/add_group';
};

export type AddAPermissionToAGroupResponses = {
  /**
   * The request was successful, and the server has returned the requested resource in the response body.
   */
  200: {
    data: {
      [key: string]: unknown;
    };
  };
};

export type AddAPermissionToAGroupResponse =
  AddAPermissionToAGroupResponses[keyof AddAPermissionToAGroupResponses];

export type RemovePermissionFromAuserData = {
  body?: never;
  path?: never;
  query: {
    /**
     * User login
     */
    login: string;
    /**
     * The permission you would like to revoke from the user.
     *
     * Possible values for global permissions: admin, gateadmin, profileadmin, provisioning, scan, applicationcreator, portfoliocreator
     *
     * Possible values for project permissions admin, codeviewer, issueadmin, securityhotspotadmin, scan, user
     */
    permission: string;
    /**
     * Project id
     */
    projectId?: string;
    /**
     * Project key
     */
    projectKey?: string;
  };
  url: '/permissions/remove_user';
};

export type RemovePermissionFromAuserResponses = {
  /**
   * The request was successful, and the server has returned the requested resource in the response body.
   */
  200: {
    data: {
      [key: string]: unknown;
    };
  };
};

export type RemovePermissionFromAuserResponse =
  RemovePermissionFromAuserResponses[keyof RemovePermissionFromAuserResponses];

export type RemoveAPermissionFromAGroupData = {
  body?: never;
  path?: never;
  query: {
    /**
     * Group name or 'anyone' (case insensitive)
     */
    groupName: string;
    /**
     * The permission you would like to revoke from the group.
     *
     * Possible values for global permissions: admin, gateadmin, profileadmin, provisioning, scan, applicationcreator, portfoliocreator
     *
     * Possible values for project permissions admin, codeviewer, issueadmin, securityhotspotadmin, scan, user
     */
    permission: string;
    /**
     * Project id
     */
    projectId?: string;
    /**
     * Project key
     */
    projectKey?: string;
  };
  url: '/permissions/remove_group';
};

export type RemoveAPermissionFromAGroupResponses = {
  /**
   * The request was successful, and the server has returned the requested resource in the response body.
   */
  200: {
    data: {
      [key: string]: unknown;
    };
  };
};

export type RemoveAPermissionFromAGroupResponse =
  RemoveAPermissionFromAGroupResponses[keyof RemoveAPermissionFromAGroupResponses];

export type GetAListOfProjectsAndLicenseUsageData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/projects/license_usage';
};

export type GetAListOfProjectsAndLicenseUsageErrors = {
  /**
   * Authentication is required to access the requested resource. The client must include the appropriate credentials.
   */
  401: {
    message: string;
  };
  /**
   * The server understood the request, but refuses to authorize it. Ensure the client has appropriate permissions.
   */
  403: {
    message: string;
  };
  /**
   * The server encountered an unexpected condition that prevented it from fulfilling the request. Report the issue to the support team if it persists.
   */
  500: {
    message: string;
  };
};

export type GetAListOfProjectsAndLicenseUsageError =
  GetAListOfProjectsAndLicenseUsageErrors[keyof GetAListOfProjectsAndLicenseUsageErrors];

export type GetAListOfProjectsAndLicenseUsageResponses = {
  /**
   * The request was successful, and the server has returned the requested resource in the response body.
   */
  200: {
    projects: Array<{
      projectKey: string;
      projectName: string;
      branch: string;
      licenseUsagePercentage: number;
      linesOfCode: number;
    }>;
  };
};

export type GetAListOfProjectsAndLicenseUsageResponse =
  GetAListOfProjectsAndLicenseUsageResponses[keyof GetAListOfProjectsAndLicenseUsageResponses];

export type ClientOptions = {
  baseUrl: 'http://next.sonarqube.com/sonarqube/api/v2' | (string & {});
};
