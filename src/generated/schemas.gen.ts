// This file is auto-generated by @hey-api/openapi-ts

export const UserCreateRestRequestSchema = {
  type: 'object',
  properties: {
    email: {
      type: 'string',
      description: 'User email',
      maxLength: 100,
      minLength: 1,
    },
    local: {
      type: 'boolean',
      default: 'true',
      description:
        'Specify if the user should be authenticated from SonarQube server or from an external authentication system. Password should not be set when local is set to false.',
    },
    login: {
      type: 'string',
      description: 'User login',
      maxLength: 100,
      minLength: 2,
    },
    name: {
      type: 'string',
      description: 'User name',
      maxLength: 200,
      minLength: 0,
    },
    scmAccounts: {
      type: 'array',
      description: 'List of SCM accounts.',
      items: {
        type: 'string',
      },
    },
  },
  required: ['login', 'name'],
} as const;

export const UserRestResponseForAdminsSchema = {
  type: 'object',
  properties: {
    id: {
      type: 'string',
      readOnly: true,
    },
    login: {
      type: 'string',
    },
    name: {
      type: 'string',
    },
    email: {
      type: 'string',
    },
    active: {
      type: 'boolean',
      readOnly: true,
    },
    local: {
      type: 'boolean',
      readOnly: true,
    },
    managed: {
      type: 'boolean',
      readOnly: true,
    },
    externalLogin: {
      type: 'string',
    },
    externalProvider: {
      type: 'string',
    },
    externalId: {
      type: 'string',
    },
    avatar: {
      type: 'string',
    },
    sonarQubeLastConnectionDate: {
      type: 'string',
      readOnly: true,
    },
    sonarLintLastConnectionDate: {
      type: 'string',
      readOnly: true,
    },
    scmAccounts: {
      type: 'array',
      items: {
        type: 'string',
      },
    },
  },
} as const;

export const EmailConfigurationCreateRestRequestSchema = {
  type: 'object',
  properties: {
    host: {
      type: 'string',
      description: 'URL of your SMTP server',
    },
    port: {
      type: 'string',
      description: 'Port of your SMTP server (usually 25, 587 or 465)',
    },
    securityProtocol: {
      type: 'string',
      description:
        'Security protocol used to connect to your SMTP server (SSLTLS is recommended)',
      enum: ['NONE', 'SSLTLS', 'STARTTLS'],
    },
    fromAddress: {
      type: 'string',
      description: 'Address emails will come from',
    },
    fromName: {
      type: 'string',
      description: 'Name emails will come from (usually "SonarQube")',
    },
    subjectPrefix: {
      type: 'string',
      description:
        'Prefix added to email so they can be easily recognized (usually "[SonarQube]")',
    },
    authMethod: {
      type: 'string',
      description:
        'Authentication method used to connect to the SMTP server. OAuth is only supported for Microsoft Exchange',
      enum: ['BASIC', 'OAUTH'],
    },
    username: {
      type: 'string',
      description:
        'For Basic and OAuth authentication: username used to authenticate to the SMTP server',
    },
    oauthAuthenticationHost: {
      type: 'string',
      description:
        'For OAuth authentication: host of the Identity Provider issuing access tokens',
    },
    oauthTenant: {
      type: 'string',
      description: 'For OAuth authentication: Microsoft tenant',
    },
  },
  required: [
    'authMethod',
    'fromAddress',
    'fromName',
    'host',
    'port',
    'securityProtocol',
    'subjectPrefix',
    'username',
  ],
} as const;

export const EmailConfigurationResourceSchema = {
  type: 'object',
  properties: {
    id: {
      type: 'string',
      readOnly: true,
    },
    host: {
      type: 'string',
      description: 'URL of your SMTP server',
    },
    port: {
      type: 'string',
      description: 'Port of your SMTP server (usually 25, 587 or 465)',
    },
    securityProtocol: {
      type: 'string',
      description:
        'Security protocol used to connect to your SMTP server (SSLTLS is recommended)',
      enum: ['NONE', 'SSLTLS', 'STARTTLS'],
    },
    fromAddress: {
      type: 'string',
      description: 'Address emails will come from',
    },
    fromName: {
      type: 'string',
      description: 'Name emails will come from (usually "SonarQube")',
    },
    subjectPrefix: {
      type: 'string',
      description:
        'Prefix added to email so they can be easily recognized (usually "[SonarQube]")',
    },
    authMethod: {
      type: 'string',
      description:
        'Authentication method used to connect to the SMTP server. OAuth is only supported for Microsoft Exchange',
      enum: ['BASIC', 'OAUTH'],
    },
    username: {
      type: 'string',
      description:
        'For Basic and OAuth authentication: username used to authenticate to the SMTP server',
    },
    isBasicPasswordSet: {
      type: 'boolean',
      description: 'For Basic authentication: has the password field been set?',
    },
    oauthAuthenticationHost: {
      type: 'string',
      description:
        'For OAuth authentication: host of the Identity Provider issuing access tokens',
    },
    isOauthClientIdSet: {
      type: 'boolean',
      description:
        'For OAuth authentication: has the Client ID field been set?',
    },
    isOauthClientSecretSet: {
      type: 'boolean',
      description:
        'For OAuth authentication: has the Client secret field been set?',
    },
    oauthTenant: {
      type: 'string',
      description: 'For OAuth authentication: Microsoft tenant',
    },
  },
} as const;

export const AwarenessBannerClickedRequestSchema = {
  type: 'object',
  properties: {
    bannerType: {
      type: 'string',
      enum: ['ENABLE', 'LEARN_MORE'],
    },
  },
} as const;

export const AwarenessBannerClickedResponseSchema = {
  type: 'object',
  properties: {
    id: {
      type: 'string',
      readOnly: true,
    },
  },
} as const;

export const FixSuggestionPostRequestSchema = {
  type: 'object',
  properties: {
    issueId: {
      type: 'string',
      description: 'Issue key',
    },
  },
  required: ['issueId'],
} as const;

export const ChangeDtoSchema = {
  type: 'object',
  properties: {
    startLine: {
      type: 'integer',
      format: 'int32',
    },
    endLine: {
      type: 'integer',
      format: 'int32',
    },
    newCode: {
      type: 'string',
    },
  },
} as const;

export const FixSuggestionResponseSchema = {
  type: 'object',
  properties: {
    id: {
      type: 'string',
      format: 'uuid',
    },
    issueId: {
      type: 'string',
    },
    explanation: {
      type: 'string',
    },
    changes: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/ChangeDto',
      },
    },
  },
} as const;

export const GitlabSynchronizationRunResourceSchema = {
  type: 'object',
  properties: {
    id: {
      type: 'string',
      readOnly: true,
    },
  },
} as const;

export const PermissionMappingsPostRequestSchema = {
  type: 'object',
  properties: {
    role: {
      type: 'string',
      description: 'Custom role name',
    },
    permissions: {
      $ref: '#/components/schemas/RestPermissions',
      description: 'Set of SonarQube permissions to apply',
    },
  },
  required: ['permissions', 'role'],
} as const;

export const RestPermissionsSchema = {
  type: 'object',
  properties: {
    user: {
      type: 'boolean',
      description: 'Browse',
    },
    codeViewer: {
      type: 'boolean',
      description: 'See Source Code',
    },
    issueAdmin: {
      type: 'boolean',
      description: 'Administer Issues',
    },
    securityHotspotAdmin: {
      type: 'boolean',
      description: 'Administer Security Hotspots',
    },
    admin: {
      type: 'boolean',
      description: 'Administer',
    },
    scan: {
      type: 'boolean',
      description: 'Execute Analysis',
    },
  },
  required: [
    'admin',
    'codeViewer',
    'issueAdmin',
    'scan',
    'securityHotspotAdmin',
    'user',
  ],
} as const;

export const PermissionMappingsResourceSchema = {
  type: 'object',
  properties: {
    id: {
      type: 'string',
    },
    role: {
      type: 'string',
    },
    baseRole: {
      type: 'boolean',
    },
    permissions: {
      $ref: '#/components/schemas/RestPermissions',
    },
  },
} as const;

export const GitlabConfigurationCreateRestRequestSchema = {
  type: 'object',
  properties: {
    enabled: {
      type: 'boolean',
      description: 'Enable Gitlab authentication',
    },
    applicationId: {
      type: 'string',
      description: 'Gitlab Application id',
    },
    url: {
      type: 'string',
      description:
        'Url of Gitlab instance for authentication (for instance https://gitlab.com)',
    },
    synchronizeGroups: {
      type: 'boolean',
      description: 'Set whether to synchronize groups',
    },
    allowedGroups: {
      type: 'array',
      items: {
        type: 'string',
      },
    },
    provisioningType: {
      type: 'string',
      description: 'Type of synchronization',
      enum: ['JIT', 'AUTO_PROVISIONING'],
    },
    allowUsersToSignUp: {
      type: 'boolean',
      description: 'Allow user to sign up',
    },
  },
  required: [
    'allowedGroups',
    'applicationId',
    'enabled',
    'provisioningType',
    'synchronizeGroups',
    'url',
  ],
} as const;

export const GitlabConfigurationResourceSchema = {
  type: 'object',
  properties: {
    id: {
      type: 'string',
      readOnly: true,
    },
    enabled: {
      type: 'boolean',
    },
    applicationId: {
      type: 'string',
      description: 'Gitlab Application id',
    },
    url: {
      type: 'string',
      description:
        'Url of Gitlab instance for authentication (for instance https://gitlab.com/api/v4)',
    },
    synchronizeGroups: {
      type: 'boolean',
    },
    allowedGroups: {
      type: 'array',
      description: 'Root Gitlab groups allowed to authenticate and provisioned',
      items: {
        type: 'string',
      },
    },
    allowUsersToSignUp: {
      type: 'boolean',
    },
    provisioningType: {
      type: 'string',
      enum: ['JIT', 'AUTO_PROVISIONING'],
    },
    isProvisioningTokenSet: {
      type: 'boolean',
      description: 'Whether or not the provisioningToken is defined',
      readOnly: true,
    },
    errorMessage: {
      type: 'string',
      description:
        'In case the GitLab configuration is incorrect, error message',
      readOnly: true,
    },
  },
} as const;

export const GithubConfigurationCreateRestRequestSchema = {
  type: 'object',
  properties: {
    enabled: {
      type: 'boolean',
      description: 'Enable GitHub authentication',
    },
    applicationId: {
      type: 'string',
      description:
        "The App ID is found on your GitHub App's page on GitHub at Settings > Developer Settings > GitHub Apps.",
    },
    synchronizeGroups: {
      type: 'boolean',
      description: `Synchronize GitHub team with SonarQube group memberships when users log in to SonarQube.
For each GitHub team they belong to, users will be associated to a group of the same name if it exists in SonarQube.
`,
    },
    apiUrl: {
      type: 'string',
      description:
        'The API url for a GitHub instance. https://api.github.com/ for Github.com, https://github.company.com/api/v3/ when using Github Enterprise',
    },
    webUrl: {
      type: 'string',
      description: `The WEB url for a GitHub instance. https://github.com/ for Github.com, https://github.company.com/ when using GitHub Enterprise.
`,
    },
    allowedOrganizations: {
      type: 'array',
      items: {
        type: 'string',
      },
    },
    provisioningType: {
      type: 'string',
      description: 'Type of synchronization',
      enum: ['JIT', 'AUTO_PROVISIONING'],
    },
    allowUsersToSignUp: {
      type: 'boolean',
      description: 'Allow user to sign up',
    },
    projectVisibility: {
      type: 'boolean',
      description: `Change project visibility based on GitHub repository visibility.
If disabled, every provisioned project will be private in SonarQube and visible only to users with explicit GitHub permissions for the corresponding repository.
Changes take effect at the next synchronization.
`,
    },
    userConsentRequiredAfterUpgrade: {
      type: 'boolean',
      description: 'Admin consent to synchronize permissions from GitHub',
    },
  },
  required: [
    'allowedOrganizations',
    'apiUrl',
    'applicationId',
    'enabled',
    'provisioningType',
    'synchronizeGroups',
    'webUrl',
  ],
} as const;

export const GithubConfigurationResourceSchema = {
  type: 'object',
  properties: {
    id: {
      type: 'string',
      readOnly: true,
    },
    enabled: {
      type: 'boolean',
    },
    applicationId: {
      type: 'string',
      description: 'GitHub Application id',
    },
    synchronizeGroups: {
      type: 'boolean',
    },
    apiUrl: {
      type: 'string',
      description:
        'Url of GitHub instance for API connectivity (for instance https://api.github.com)',
    },
    webUrl: {
      type: 'string',
      description:
        'Url of GitHub instance for authentication (for instance https://github.com)',
    },
    allowedOrganizations: {
      type: 'array',
      description:
        'GitHub organizations allowed to authenticate and provisioned',
      items: {
        type: 'string',
      },
    },
    provisioningType: {
      type: 'string',
      enum: ['JIT', 'AUTO_PROVISIONING'],
    },
    allowUsersToSignUp: {
      type: 'boolean',
    },
    projectVisibility: {
      type: 'boolean',
    },
    userConsentRequiredAfterUpgrade: {
      type: 'boolean',
    },
    errorMessage: {
      type: 'string',
      description:
        'In case the GitHub configuration is incorrect, error message',
      readOnly: true,
    },
  },
} as const;

export const BoundProjectCreateRestRequestSchema = {
  type: 'object',
  properties: {
    projectKey: {
      type: 'string',
      description: 'Key of the project to create',
    },
    projectName: {
      type: 'string',
      description: 'Name of the project to create',
    },
    devOpsPlatformSettingId: {
      type: 'string',
      description:
        'Identifier of DevOps platform configuration to use. Use /dop-translation/dop-settings to retrieve the settings and their ID',
    },
    repositoryIdentifier: {
      type: 'string',
      description: `Identifier of the DevOps platform repository to import:
- repository slug for GitHub and Bitbucket (Cloud and Server)
- repository id for GitLab
- repository name for Azure DevOps
`,
    },
    projectIdentifier: {
      type: 'string',
      description: `Identifier of the DevOps platform project in which the repository is located.
This is only needed for Azure and BitBucket Server platforms
`,
    },
    newCodeDefinitionType: {
      type: 'string',
      description: `  Project New Code Definition Type
  New code definitions of the following types are allowed:
    - PREVIOUS_VERSION
    - NUMBER_OF_DAYS
    - REFERENCE_BRANCH - will default to the main branch.
`,
    },
    newCodeDefinitionValue: {
      type: 'string',
      description: `  Project New Code Definition Value
  For each new code definition type, a different value is expected:
  - no value, when the new code definition type is PREVIOUS_VERSION and REFERENCE_BRANCH
  - a number between 1 and 90, when the new code definition type is NUMBER_OF_DAYS
`,
    },
    monorepo: {
      type: 'boolean',
      description: 'True if project is part of a mono repo.',
    },
  },
  required: [
    'devOpsPlatformSettingId',
    'monorepo',
    'projectKey',
    'projectName',
    'repositoryIdentifier',
  ],
} as const;

export const BoundProjectCreateRestResponseSchema = {
  type: 'object',
  properties: {
    projectId: {
      type: 'string',
      description: 'The identifier of the created project',
    },
    bindingId: {
      type: 'string',
      description:
        'The identifier of the binding between the created project and the DevOps platform project',
    },
  },
} as const;

export const ImpactSchema = {
  type: 'object',
  properties: {
    softwareQuality: {
      type: 'string',
      enum: ['MAINTAINABILITY', 'RELIABILITY', 'SECURITY'],
    },
    severity: {
      type: 'string',
      enum: ['INFO', 'LOW', 'MEDIUM', 'HIGH', 'BLOCKER'],
    },
  },
} as const;

export const ParameterSchema = {
  type: 'object',
  properties: {
    key: {
      type: 'string',
    },
    htmlDescription: {
      type: 'string',
      readOnly: true,
    },
    defaultValue: {
      type: 'string',
    },
    type: {
      type: 'string',
      enum: ['STRING', 'TEXT', 'BOOLEAN', 'INTEGER', 'FLOAT'],
      readOnly: true,
    },
  },
} as const;

export const RuleCreateRestRequestSchema = {
  type: 'object',
  properties: {
    key: {
      type: 'string',
      description:
        'Key of the custom rule to create, must include the repository',
      maxLength: 200,
      minLength: 0,
    },
    templateKey: {
      type: 'string',
      description:
        'Key of the rule template to be used to create the custom rule',
      maxLength: 200,
      minLength: 0,
    },
    name: {
      type: 'string',
      description: 'Rule name',
      maxLength: 200,
      minLength: 0,
    },
    markdownDescription: {
      type: 'string',
      description: 'Rule description in markdown format',
    },
    status: {
      type: 'string',
      default: 'READY',
      description: 'Rule status',
      enum: ['BETA', 'DEPRECATED', 'READY', 'REMOVED'],
    },
    parameters: {
      type: 'array',
      description: 'Custom rule parameters',
      items: {
        $ref: '#/components/schemas/Parameter',
      },
    },
    cleanCodeAttribute: {
      type: 'string',
      description: 'Clean code attribute',
      enum: [
        'CONVENTIONAL',
        'FORMATTED',
        'IDENTIFIABLE',
        'CLEAR',
        'COMPLETE',
        'EFFICIENT',
        'LOGICAL',
        'DISTINCT',
        'FOCUSED',
        'MODULAR',
        'TESTED',
        'LAWFUL',
        'RESPECTFUL',
        'TRUSTWORTHY',
      ],
    },
    impacts: {
      type: 'array',
      description: 'Impacts',
      items: {
        $ref: '#/components/schemas/Impact',
      },
    },
    severity: {
      type: 'string',
      description: 'Severity',
    },
    type: {
      type: 'string',
      description: 'Rule type',
      enum: ['CODE_SMELL', 'BUG', 'VULNERABILITY', 'SECURITY_HOTSPOT'],
    },
  },
  required: ['impacts', 'key', 'markdownDescription', 'name', 'templateKey'],
} as const;

export const RuleDescriptionSectionContextRestResponseSchema = {
  type: 'object',
  properties: {
    key: {
      type: 'string',
    },
    displayName: {
      type: 'string',
    },
  },
  readOnly: true,
} as const;

export const RuleDescriptionSectionRestResponseSchema = {
  type: 'object',
  properties: {
    key: {
      type: 'string',
      readOnly: true,
    },
    content: {
      type: 'string',
      readOnly: true,
    },
    context: {
      $ref: '#/components/schemas/RuleDescriptionSectionContextRestResponse',
      readOnly: true,
    },
  },
} as const;

export const RuleRestResponseSchema = {
  type: 'object',
  properties: {
    id: {
      type: 'string',
    },
    key: {
      type: 'string',
    },
    repositoryKey: {
      type: 'string',
    },
    name: {
      type: 'string',
    },
    severity: {
      type: 'string',
    },
    type: {
      type: 'string',
      enum: ['CODE_SMELL', 'BUG', 'VULNERABILITY', 'SECURITY_HOTSPOT'],
    },
    impacts: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/Impact',
      },
    },
    cleanCodeAttribute: {
      type: 'string',
      enum: [
        'CONVENTIONAL',
        'FORMATTED',
        'IDENTIFIABLE',
        'CLEAR',
        'COMPLETE',
        'EFFICIENT',
        'LOGICAL',
        'DISTINCT',
        'FOCUSED',
        'MODULAR',
        'TESTED',
        'LAWFUL',
        'RESPECTFUL',
        'TRUSTWORTHY',
      ],
    },
    cleanCodeAttributeCategory: {
      type: 'string',
      enum: ['ADAPTABLE', 'CONSISTENT', 'INTENTIONAL', 'RESPONSIBLE'],
    },
    status: {
      type: 'string',
      enum: ['BETA', 'DEPRECATED', 'READY', 'REMOVED'],
    },
    external: {
      type: 'boolean',
    },
    createdAt: {
      type: 'string',
    },
    descriptionSections: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/RuleDescriptionSectionRestResponse',
      },
    },
    markdownDescription: {
      type: 'string',
    },
    gapDescription: {
      type: 'string',
    },
    htmlNote: {
      type: 'string',
    },
    markdownNote: {
      type: 'string',
    },
    educationPrinciples: {
      type: 'array',
      items: {
        type: 'string',
      },
    },
    template: {
      type: 'boolean',
    },
    templateId: {
      type: 'string',
    },
    tags: {
      type: 'array',
      items: {
        type: 'string',
      },
    },
    systemTags: {
      type: 'array',
      items: {
        type: 'string',
      },
    },
    languageKey: {
      type: 'string',
    },
    languageName: {
      type: 'string',
    },
    parameters: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/Parameter',
      },
    },
    remediationFunctionType: {
      type: 'string',
    },
    remediationFunctionGapMultiplier: {
      type: 'string',
    },
    remediationFunctionBaseEffort: {
      type: 'string',
    },
  },
  readOnly: true,
} as const;

export const GroupCreateRestRequestSchema = {
  type: 'object',
  properties: {
    name: {
      type: 'string',
      description:
        "Name for the new group. Must be unique. The value 'anyone' is reserved and cannot be used.",
      maxLength: 255,
      minLength: 1,
    },
    description: {
      type: 'string',
      description: 'Description for the new group.',
      maxLength: 200,
      minLength: 0,
    },
  },
  required: ['name'],
} as const;

export const GroupRestResponseSchema = {
  type: 'object',
  properties: {
    id: {
      type: 'string',
      readOnly: true,
    },
    name: {
      type: 'string',
    },
    description: {
      type: 'string',
    },
    managed: {
      type: 'boolean',
      readOnly: true,
    },
    default: {
      type: 'boolean',
      readOnly: true,
    },
  },
} as const;

export const GroupMembershipCreateRestRequestSchema = {
  type: 'object',
  properties: {
    userId: {
      type: 'string',
      description: 'ID of the user to add to group.',
    },
    groupId: {
      type: 'string',
      description: 'ID of the group where a member needs to be added.',
    },
  },
} as const;

export const GroupMembershipRestResponseSchema = {
  type: 'object',
  properties: {
    id: {
      type: 'string',
      readOnly: true,
    },
    groupId: {
      type: 'string',
      readOnly: true,
    },
    userId: {
      type: 'string',
      readOnly: true,
    },
  },
} as const;

export const UpdateFieldListStringSchema = {
  type: 'object',
  properties: {
    value: {
      type: 'array',
      items: {
        type: 'string',
      },
    },
    defined: {
      type: 'boolean',
    },
  },
} as const;

export const UpdateFieldStringSchema = {
  type: 'object',
  properties: {
    value: {
      type: 'string',
    },
    defined: {
      type: 'boolean',
    },
  },
} as const;

export const UserUpdateRestRequestSchema = {
  type: 'object',
  properties: {
    login: {
      $ref: '#/components/schemas/UpdateFieldString',
      description: 'User login',
    },
    name: {
      type: 'string',
      description: 'User first name and last name',
      maxLength: 200,
      minLength: 0,
    },
    email: {
      type: 'string',
      description: 'Email',
      maxLength: 100,
      minLength: 1,
    },
    scmAccounts: {
      $ref: '#/components/schemas/UpdateFieldListString',
    },
    externalProvider: {
      type: 'string',
      description: `New identity provider. Only providers configured in your platform are supported. This could be: github, gitlab, bitbucket, saml, LDAP, LDAP_{serverKey}
(according to your server configuration file).
Warning: when this is updated, the user will only be able to authenticate using the new identity provider. Also, it is not possible to remove the identity provider of a user.
`,
    },
    externalLogin: {
      type: 'string',
      description:
        'New external login, usually the login used in the authentication system.',
      maxLength: 255,
      minLength: 1,
    },
    externalId: {
      type: 'string',
      description: 'New external id in the authentication system.',
      maxLength: 255,
      minLength: 1,
    },
  },
} as const;

export const EmailConfigurationUpdateRestRequestSchema = {
  type: 'object',
  properties: {
    host: {
      type: 'string',
      description: 'URL of your SMTP server',
    },
    port: {
      type: 'string',
      description: 'Port of your SMTP server (usually 25, 587 or 465)',
    },
    securityProtocol: {
      type: 'string',
      description:
        'Security protocol used to connect to your SMTP server (SSLTLS is recommended)',
      enum: ['NONE', 'SSLTLS', 'STARTTLS'],
    },
    fromAddress: {
      type: 'string',
      description: 'Address emails will come from',
    },
    fromName: {
      type: 'string',
      description: 'Name emails will come from (usually "SonarQube")',
    },
    subjectPrefix: {
      type: 'string',
      description:
        'Prefix added to email so they can be easily recognized (usually "[SonarQube]")',
    },
    authMethod: {
      type: 'string',
      description:
        'Authentication method used to connect to the SMTP server. OAuth is only supported for Microsoft Exchange',
      enum: ['BASIC', 'OAUTH'],
    },
    username: {
      type: 'string',
      description:
        'For Basic and OAuth authentication: username used to authenticate to the SMTP server',
    },
    basicPassword: {
      type: 'string',
      description:
        'For basic authentication: password used to authenticate to the SMTP server',
    },
    oauthAuthenticationHost: {
      type: 'string',
      description:
        'For OAuth authentication: host of the Identity Provider issuing access tokens',
    },
    oauthClientId: {
      type: 'string',
      description:
        'For OAuth authentication: Client ID provided by Microsoft Exchange when registering the application',
    },
    oauthClientSecret: {
      type: 'string',
      description:
        'For OAuth authentication: Client password provided by Microsoft Exchange when registering the application',
    },
    oauthTenant: {
      type: 'string',
      description: 'For OAuth authentication: Microsoft tenant',
    },
  },
} as const;

export const FeatureEnablementRequestSchema = {
  type: 'object',
  properties: {
    enablement: {
      type: 'boolean',
      description: 'Whether SCA is enabled or not',
    },
  },
} as const;

export const FeatureEnablementResourceSchema = {
  type: 'object',
  properties: {
    enablement: {
      type: 'boolean',
    },
  },
} as const;

export const DevOpsPermissionMappingUpdateRequestSchema = {
  type: 'object',
  properties: {
    permissions: {
      $ref: '#/components/schemas/PermissionMappingUpdate',
      description: 'Set of SonarQube permissions to apply',
    },
  },
} as const;

export const PermissionMappingUpdateSchema = {
  type: 'object',
  properties: {
    user: {
      type: 'boolean',
    },
    codeViewer: {
      type: 'boolean',
    },
    issueAdmin: {
      type: 'boolean',
    },
    securityHotspotAdmin: {
      type: 'boolean',
    },
    admin: {
      type: 'boolean',
    },
    scan: {
      type: 'boolean',
    },
  },
} as const;

export const GitlabConfigurationUpdateRestRequestSchema = {
  type: 'object',
  properties: {
    enabled: {
      type: 'boolean',
      description: 'Enable Gitlab authentication',
    },
    applicationId: {
      type: 'string',
      description: 'Gitlab Application id',
    },
    url: {
      type: 'string',
      description:
        'Url of Gitlab instance for authentication (for instance https://gitlab.com/api/v4)',
    },
    secret: {
      type: 'string',
      description: 'Secret of the application',
    },
    synchronizeGroups: {
      type: 'boolean',
      description: 'Set whether to synchronize groups',
    },
    allowedGroups: {
      $ref: '#/components/schemas/UpdateFieldListString',
    },
    provisioningType: {
      type: 'string',
      description: 'Type of synchronization',
      enum: ['JIT', 'AUTO_PROVISIONING'],
    },
    allowUsersToSignUp: {
      type: 'boolean',
      description: 'Allow user to sign up',
    },
    provisioningToken: {
      type: 'string',
      description: 'Gitlab token for provisioning',
      maxLength: 2147483647,
      minLength: 1,
    },
  },
} as const;

export const GithubConfigurationUpdateRestRequestSchema = {
  type: 'object',
  properties: {
    enabled: {
      type: 'boolean',
      description: 'Enable GitHub authentication',
    },
    clientId: {
      type: 'string',
      description: 'GitHub Client ID',
    },
    clientSecret: {
      type: 'string',
      description: 'GitHub Client secret',
    },
    applicationId: {
      type: 'string',
      description: 'GitHub Application id',
    },
    privateKey: {
      type: 'string',
      description: 'GitHub Private key',
    },
    synchronizeGroups: {
      type: 'boolean',
      description: 'Set whether to synchronize groups',
    },
    apiUrl: {
      type: 'string',
      description:
        'Url of GitHub instance for API connectivity (for instance https://api.github.com)',
    },
    webUrl: {
      type: 'string',
      description:
        'Url of GitHub instance for authentication (for instance https://github.com)',
    },
    allowedOrganizations: {
      $ref: '#/components/schemas/UpdateFieldListString',
    },
    provisioningType: {
      type: 'string',
      description: 'Type of synchronization',
      enum: ['JIT', 'AUTO_PROVISIONING'],
    },
    allowUsersToSignUp: {
      type: 'boolean',
      description: 'Allow user to sign up',
    },
    projectVisibility: {
      type: 'boolean',
      description: 'Sync project visibility',
    },
    userConsentRequiredAfterUpgrade: {
      type: 'boolean',
      description: 'Admin consent to synchronize permissions from GitHub',
    },
  },
} as const;

export const ModeResourceSchema = {
  type: 'object',
  properties: {
    mode: {
      type: 'string',
      enum: ['MQR', 'STANDARD_EXPERIENCE'],
    },
    modified: {
      type: 'boolean',
      readOnly: true,
    },
  },
  required: ['mode'],
} as const;

export const GroupUpdateRestRequestSchema = {
  type: 'object',
  properties: {
    name: {
      type: 'string',
      description: 'Group name',
      maxLength: 255,
      minLength: 1,
    },
    description: {
      type: 'string',
      description: 'Description of the group',
      maxLength: 200,
      minLength: 0,
    },
  },
} as const;

export const PageRestResponseSchema = {
  type: 'object',
  properties: {
    pageIndex: {
      type: 'integer',
      format: 'int32',
    },
    pageSize: {
      type: 'integer',
      format: 'int32',
    },
    total: {
      type: 'integer',
      format: 'int32',
    },
  },
} as const;

export const UsersSearchRestResponseSchema = {
  type: 'object',
  properties: {
    users: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/UserRestResponseForAdmins',
      },
    },
    page: {
      $ref: '#/components/schemas/PageRestResponse',
    },
  },
} as const;

export const DatabaseMigrationsResponseSchema = {
  type: 'object',
  properties: {
    status: {
      type: 'string',
    },
    completedSteps: {
      type: 'integer',
      format: 'int32',
    },
    totalSteps: {
      type: 'integer',
      format: 'int32',
    },
    startedAt: {
      type: 'string',
    },
    message: {
      type: 'string',
    },
    expectedFinishTimestamp: {
      type: 'string',
    },
  },
} as const;

export const HealthSchema = {
  type: 'object',
  properties: {
    status: {
      type: 'string',
      enum: ['GREEN', 'YELLOW', 'RED'],
    },
    causes: {
      type: 'array',
      items: {
        type: 'string',
      },
      uniqueItems: true,
    },
  },
} as const;

export const EmailConfigurationSearchRestResponseSchema = {
  type: 'object',
  properties: {
    emailConfigurations: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/EmailConfigurationResource',
      },
    },
    page: {
      $ref: '#/components/schemas/PageRestResponse',
    },
  },
} as const;

export const ReleaseSearchResourceSchema = {
  type: 'object',
  properties: {
    key: {
      type: 'string',
    },
    packageUrl: {
      type: 'string',
    },
    packageManager: {
      type: 'string',
    },
    packageName: {
      type: 'string',
    },
    version: {
      type: 'string',
    },
    licenseExpression: {
      type: 'string',
    },
    known: {
      type: 'boolean',
    },
    newInPullRequest: {
      type: 'boolean',
    },
    directSummary: {
      type: 'boolean',
    },
    scopeSummary: {
      type: 'string',
    },
    dependencyFilePaths: {
      type: 'array',
      items: {
        type: 'string',
      },
    },
  },
} as const;

export const ReleasesSearchRestResponseSchema = {
  type: 'object',
  properties: {
    releases: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/ReleaseSearchResource',
      },
    },
    packageManagerCounts: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/ScaReleaseByPackageManagerCountDto',
      },
    },
    page: {
      $ref: '#/components/schemas/PageRestResponse',
    },
  },
} as const;

export const ScaReleaseByPackageManagerCountDtoSchema = {
  type: 'object',
  properties: {
    packageManager: {
      type: 'string',
    },
    releaseCount: {
      type: 'integer',
      format: 'int32',
    },
  },
} as const;

export const DependencyResourceSchema = {
  type: 'object',
  properties: {
    key: {
      type: 'string',
    },
    direct: {
      type: 'boolean',
    },
    scope: {
      type: 'string',
    },
    productionScope: {
      type: 'boolean',
    },
    userDependencyFilePath: {
      type: 'string',
    },
    lockfileDependencyFilePath: {
      type: 'string',
    },
    chains: {
      type: 'array',
      items: {
        type: 'array',
        items: {
          type: 'string',
        },
      },
    },
    newInPullRequest: {
      type: 'boolean',
    },
  },
} as const;

export const IssueResourceSchema = {
  type: 'object',
  properties: {
    key: {
      type: 'string',
    },
    severity: {
      type: 'string',
    },
    type: {
      type: 'string',
    },
    createdAt: {
      type: 'string',
    },
    vulnerabilityId: {
      type: 'string',
    },
    cweIds: {
      type: 'array',
      items: {
        type: 'string',
      },
    },
    cvssScore: {
      type: 'string',
    },
    spdxLicenseId: {
      type: 'string',
    },
  },
} as const;

export const ReleaseDetailResourceSchema = {
  type: 'object',
  properties: {
    key: {
      type: 'string',
    },
    packageUrl: {
      type: 'string',
    },
    packageManager: {
      type: 'string',
    },
    packageName: {
      type: 'string',
    },
    version: {
      type: 'string',
    },
    licenseExpression: {
      type: 'string',
    },
    known: {
      type: 'boolean',
    },
    newInPullRequest: {
      type: 'boolean',
    },
    directSummary: {
      type: 'boolean',
    },
    scopeSummary: {
      type: 'string',
    },
    productionScopeSummary: {
      type: 'boolean',
    },
    dependencies: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/DependencyResource',
      },
    },
    issues: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/IssueResource',
      },
    },
  },
} as const;

export const DependencyRiskResourceSchema = {
  type: 'object',
  properties: {
    key: {
      type: 'string',
    },
    severity: {
      type: 'string',
    },
    release: {
      $ref: '#/components/schemas/ReleaseSearchResource',
    },
    type: {
      type: 'string',
    },
    createdAt: {
      type: 'string',
    },
    vulnerabilityId: {
      type: 'string',
    },
    cweIds: {
      type: 'array',
      items: {
        type: 'string',
      },
    },
    cvssScore: {
      type: 'string',
    },
    spdxLicenseId: {
      type: 'string',
    },
  },
} as const;

export const DependencyRisksSearchRestResponseSchema = {
  type: 'object',
  properties: {
    issuesReleases: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/DependencyRiskResource',
      },
    },
    page: {
      $ref: '#/components/schemas/PageRestResponse',
    },
  },
} as const;

export const AffectedPackageResourceSchema = {
  type: 'object',
  properties: {
    purl: {
      type: 'string',
    },
    recommendation: {
      type: 'string',
    },
    recommendationDetails: {
      $ref: '#/components/schemas/VulnerabilityRecommendationDetailsResource',
    },
    versionOptions: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/VersionOptionResource',
      },
    },
    affectedVersions: {
      type: 'array',
      items: {
        type: 'string',
      },
    },
    unaffectedVersions: {
      type: 'string',
    },
  },
} as const;

export const DependencyRiskDetailsResourceSchema = {
  type: 'object',
  properties: {
    key: {
      type: 'string',
    },
    severity: {
      type: 'string',
    },
    release: {
      $ref: '#/components/schemas/ReleaseSearchResource',
    },
    type: {
      type: 'string',
    },
    createdAt: {
      type: 'string',
    },
    vulnerability: {
      $ref: '#/components/schemas/VulnerabilityResource',
    },
    spdxLicenseId: {
      type: 'string',
    },
  },
} as const;

export const VersionOptionResourceSchema = {
  type: 'object',
  properties: {
    version: {
      type: 'string',
      description: 'The version being presented as an option',
    },
    vulnerabilityIds: {
      type: 'array',
      description: 'Vulnerability IDs affecting this version',
      items: {
        type: 'string',
      },
    },
    prerelease: {
      type: 'boolean',
      description: 'Is this version a pre-release version',
    },
    fixLevel: {
      type: 'string',
      description: 'Describes which vulnerabilities are fixed',
      enum: ['COMPLETE', 'PARTIAL', 'NONE', 'UNKNOWN'],
    },
    descriptionCode: {
      type: 'string',
      description: 'How the frontend should label this version',
      enum: [
        'VERSION_IN_USE',
        'NEAREST_PARTIAL',
        'NEAREST_COMPLETE',
        'LATEST_PARTIAL',
        'LATEST_COMPLETE',
        'LATEST_STABLE',
        'LATEST_PRERELEASE',
        'UNKNOWN',
      ],
    },
  },
} as const;

export const VulnerabilityRecommendationDetailsResourceSchema = {
  type: 'object',
  properties: {
    impactScore: {
      type: 'integer',
      format: 'int32',
    },
    impactDescription: {
      type: 'string',
    },
    realIssue: {
      type: 'boolean',
    },
    falsePositiveReason: {
      type: 'string',
    },
    includesDev: {
      type: 'boolean',
    },
    specificMethodsAffected: {
      type: 'boolean',
    },
    specificMethodsDescription: {
      type: 'string',
    },
    otherConditions: {
      type: 'boolean',
    },
    otherConditionsDescription: {
      type: 'string',
    },
    workaroundAvailable: {
      type: 'boolean',
    },
    workaroundDescription: {
      type: 'string',
    },
    visibility: {
      type: 'string',
    },
  },
} as const;

export const VulnerabilityReportResourceSchema = {
  type: 'object',
  properties: {
    id: {
      type: 'string',
    },
    url: {
      type: 'string',
    },
    type: {
      type: 'string',
    },
    cvssScore: {
      type: 'string',
    },
    cvssSeverity: {
      type: 'string',
    },
  },
} as const;

export const VulnerabilityResourceSchema = {
  type: 'object',
  properties: {
    vulnerabilityId: {
      type: 'string',
    },
    reports: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/VulnerabilityReportResource',
      },
    },
    description: {
      type: 'string',
    },
    epssPercentile: {
      type: 'string',
    },
    epssProbability: {
      type: 'string',
    },
    knownExploited: {
      type: 'boolean',
    },
    cweIds: {
      type: 'array',
      items: {
        type: 'string',
      },
    },
    affectedPackages: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/AffectedPackageResource',
      },
    },
  },
} as const;

export const ScaCliInfoRestResponseSchema = {
  type: 'object',
  properties: {
    id: {
      type: 'string',
    },
    filename: {
      type: 'string',
    },
    sha256: {
      type: 'string',
    },
    os: {
      type: 'string',
    },
    arch: {
      type: 'string',
    },
  },
} as const;

export const LlmModelDtoSchema = {
  type: 'object',
  properties: {
    key: {
      type: 'string',
    },
    name: {
      type: 'string',
    },
    recommended: {
      type: 'boolean',
    },
  },
} as const;

export const LlmProviderResponseDtoSchema = {
  type: 'object',
  properties: {
    key: {
      type: 'string',
    },
    name: {
      type: 'string',
    },
    selfHosted: {
      type: 'boolean',
    },
    models: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/LlmModelDto',
      },
    },
  },
} as const;

export const ServiceInfoSchema = {
  type: 'object',
  properties: {
    status: {
      type: 'string',
      enum: [
        'CONNECTION_ERROR',
        'SERVICE_ERROR',
        'SUCCESS',
        'TIMEOUT',
        'UNAUTHORIZED',
      ],
    },
    isEnabled: {
      type: 'boolean',
    },
    subscriptionType: {
      type: 'string',
      enum: ['EARLY_ACCESS', 'PAID', 'NOT_PAID'],
    },
  },
} as const;

export const SubscriptionTypeResponseSchema = {
  type: 'object',
  properties: {
    subscriptionType: {
      type: 'string',
      enum: ['EARLY_ACCESS', 'PAID', 'NOT_PAID'],
    },
  },
} as const;

export const FixSuggestionIssueResponseSchema = {
  type: 'object',
  properties: {
    issueId: {
      type: 'string',
    },
    aiSuggestion: {
      type: 'string',
      enum: [
        'AVAILABLE',
        'NOT_AVAILABLE_FILE_LEVEL_ISSUE',
        'NOT_AVAILABLE_UNSUPPORTED_RULE',
        'NOT_AVAILABLE_FILE_SIZE',
      ],
    },
  },
} as const;

export const FeatureEnablementResponseSchema = {
  type: 'object',
  properties: {
    enablement: {
      type: 'string',
      enum: [
        'DISABLED',
        'ENABLED_FOR_ALL_PROJECTS',
        'ENABLED_FOR_SOME_PROJECTS',
      ],
    },
    enabledProjectKeys: {
      type: 'array',
      items: {
        type: 'string',
      },
      uniqueItems: true,
    },
    provider: {
      $ref: '#/components/schemas/ProviderResponseDto',
    },
  },
} as const;

export const ProviderResponseDtoSchema = {
  type: 'object',
  properties: {
    key: {
      type: 'string',
    },
    modelKey: {
      type: 'string',
    },
    endpoint: {
      type: 'string',
    },
  },
} as const;

export const ProjectBindingSchema = {
  type: 'object',
  properties: {
    id: {
      type: 'string',
    },
    devOpsPlatformSettingId: {
      type: 'string',
    },
    projectId: {
      type: 'string',
    },
    projectKey: {
      type: 'string',
    },
    repository: {
      type: 'string',
    },
    slug: {
      type: 'string',
    },
  },
  required: ['devOpsPlatformSettingId', 'id', 'projectId', 'projectKey'],
} as const;

export const ProjectBindingsSearchRestResponseSchema = {
  type: 'object',
  properties: {
    projectBindings: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/ProjectBinding',
      },
    },
    page: {
      $ref: '#/components/schemas/PageRestResponse',
    },
  },
} as const;

export const PermissionMappingsSearchRestResponseSchema = {
  type: 'object',
  properties: {
    permissionMappings: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/PermissionMappingsResource',
      },
    },
  },
} as const;

export const GitlabConfigurationSearchRestResponseSchema = {
  type: 'object',
  properties: {
    gitlabConfigurations: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/GitlabConfigurationResource',
      },
    },
    page: {
      $ref: '#/components/schemas/PageRestResponse',
    },
  },
} as const;

export const GithubConfigurationSearchRestResponseSchema = {
  type: 'object',
  properties: {
    githubConfigurations: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/GithubConfigurationResource',
      },
    },
    page: {
      $ref: '#/components/schemas/PageRestResponse',
    },
  },
} as const;

export const DopSettingsResourceSchema = {
  type: 'object',
  properties: {
    id: {
      type: 'string',
      readOnly: true,
    },
    type: {
      type: 'string',
      description:
        'Supported DevOps Platform are: github, gitlab, azure, bitbucketcloud, bitbucket_server',
    },
    key: {
      type: 'string',
    },
    url: {
      type: 'string',
    },
    appId: {
      type: 'string',
    },
  },
} as const;

export const DopSettingsRestResponseSchema = {
  type: 'object',
  properties: {
    dopSettings: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/DopSettingsResource',
      },
    },
    page: {
      $ref: '#/components/schemas/PageRestResponse',
    },
  },
} as const;

export const GroupsSearchRestResponseSchema = {
  type: 'object',
  properties: {
    groups: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/GroupRestResponse',
      },
    },
    page: {
      $ref: '#/components/schemas/PageRestResponse',
    },
  },
} as const;

export const GroupsMembershipSearchRestResponseSchema = {
  type: 'object',
  properties: {
    groupMemberships: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/GroupMembershipRestResponse',
      },
    },
    page: {
      $ref: '#/components/schemas/PageRestResponse',
    },
  },
} as const;

export const JreInfoRestResponseSchema = {
  type: 'object',
  properties: {
    id: {
      type: 'string',
    },
    filename: {
      type: 'string',
    },
    sha256: {
      type: 'string',
    },
    javaPath: {
      type: 'string',
    },
    os: {
      type: 'string',
    },
    arch: {
      type: 'string',
    },
  },
} as const;

export const EngineInfoRestResponseSchema = {
  type: 'object',
  properties: {
    filename: {
      type: 'string',
    },
    sha256: {
      type: 'string',
    },
  },
} as const;

export const ActiveRuleSchema = {
  type: 'object',
  properties: {
    ruleKey: {
      $ref: '#/components/schemas/RuleKey',
    },
    name: {
      type: 'string',
    },
    severity: {
      type: 'string',
    },
    createdAt: {
      type: 'string',
    },
    updatedAt: {
      type: 'string',
    },
    internalKey: {
      type: 'string',
    },
    language: {
      type: 'string',
    },
    templateRuleKey: {
      type: 'string',
    },
    qProfileKey: {
      type: 'string',
    },
    deprecatedKeys: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/RuleKey',
      },
    },
    params: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/Param',
      },
    },
    impacts: {
      type: 'object',
      additionalProperties: {
        type: 'string',
        enum: ['INFO', 'LOW', 'MEDIUM', 'HIGH', 'BLOCKER'],
      },
    },
  },
} as const;

export const ParamSchema = {
  type: 'object',
  properties: {
    key: {
      type: 'string',
    },
    value: {
      type: 'string',
    },
  },
} as const;

export const RuleKeySchema = {
  type: 'object',
  properties: {
    repository: {
      type: 'string',
    },
    rule: {
      type: 'string',
    },
  },
} as const;

export const MetricSchema = {
  type: 'object',
  title: 'Metric for a component',
  required: [
    'key',
    'name',
    'description',
    'domain',
    'type',
    'higherValuesAreBetter',
    'qualitative',
    'hidden',
  ],
  properties: {
    key: {
      type: 'string',
    },
    name: {
      type: 'string',
    },
    type: {
      type: 'string',
    },
    domain: {
      type: 'string',
    },
    hidden: {
      type: 'boolean',
    },
    description: {
      type: 'string',
    },
    qualitative: {
      type: 'boolean',
    },
    higherValuesAreBetter: {
      type: 'boolean',
    },
  },
  description: 'A metric captured from a project',
} as const;

export const PagingSchema = {
  type: 'object',
  required: ['pageIndex', 'pageSize', 'total'],
  properties: {
    total: {
      type: 'integer',
      examples: [100],
    },
    pageSize: {
      type: 'integer',
      examples: [25],
    },
    pageIndex: {
      type: 'integer',
      examples: [1, 2],
    },
  },
  description: 'Used to represent a paged response',
} as const;

export const MeasureSchema = {
  type: 'object',
  required: ['metric', 'value', 'period'],
  properties: {
    value: {
      type: 'string',
    },
    metric: {
      type: 'string',
      examples: ['complexity', 'new_violations', 'nloc'],
    },
    period: {
      type: 'object',
      required: ['value', 'bestValue'],
      properties: {
        value: {
          type: 'boolean',
        },
        bestValue: {
          type: 'string',
          examples: ['25'],
        },
      },
    },
  },
  description: 'Measures from a project',
} as const;

export const ComponentSchema = {
  type: 'object',
  required: [
    'key',
    'name',
    'qualifier',
    'visibility',
    'lastAnalysisDate',
    'revision',
    'managed',
  ],
  properties: {
    key: {
      type: 'string',
    },
    name: {
      type: 'string',
    },
    managed: {
      type: 'string',
    },
    revision: {
      type: 'string',
    },
    qualifier: {
      type: 'string',
    },
    visibility: {
      type: 'string',
    },
    lastAnalysisDate: {
      type: 'string',
    },
  },
  description: 'A component is a representation of a Project in Sonarqube',
} as const;

export const IssueSearchResponseSchema = {
  type: 'object',
  title: 'Issue Search Response',
  required: ['paging', 'components', 'rules', 'users', 'facets', 'issues'],
  properties: {
    rules: {
      type: 'array',
      items: {
        type: 'object',
        required: ['key', 'name', 'status', 'lang', 'langName'],
        properties: {
          key: {
            type: 'string',
          },
          lang: {
            type: 'string',
          },
          name: {
            type: 'string',
          },
          status: {
            type: 'string',
          },
          langName: {
            type: 'string',
          },
        },
      },
    },
    users: {
      type: 'array',
      items: {
        type: 'object',
        required: ['login', 'name', 'active', 'avatar'],
        properties: {
          name: {
            type: 'string',
          },
          login: {
            type: 'string',
          },
          active: {
            type: 'boolean',
          },
          avatar: {
            type: 'string',
          },
        },
      },
    },
    facets: {
      type: 'array',
      items: {
        type: 'object',
        required: ['property', 'values'],
        properties: {
          values: {
            type: 'array',
            items: {
              type: 'object',
              required: ['val', 'count'],
              properties: {
                val: {
                  type: 'string',
                },
                count: {
                  type: 'number',
                },
              },
            },
          },
          property: {
            type: 'string',
          },
        },
      },
    },
    issues: {
      type: 'array',
      items: {
        type: 'object',
        required: [
          'key',
          'component',
          'project',
          'rule',
          'cleanCodeAttribute',
          'cleanCodeAttributeCategory',
          'issueStatus',
          'prioritizedRule',
          'impacts',
          'message',
          'messageFormattings',
          'line',
          'hash',
          'author',
          'effort',
          'creationDate',
          'updateDate',
          'tags',
          'comments',
          'attr',
          'transitions',
          'actions',
          'textRange',
          'flows',
          'quickFixAvailable',
          'ruleDescriptionContextKey',
          'codeVariants',
          'type',
          'severity',
          'status',
        ],
        properties: {
          key: {
            type: 'string',
          },
          attr: {
            type: 'object',
            required: ['jira-issue-key'],
            properties: {
              'jira-issue-key': {
                type: 'string',
              },
            },
          },
          hash: {
            type: 'string',
          },
          line: {
            type: 'number',
          },
          rule: {
            type: 'string',
          },
          tags: {
            type: 'array',
            items: {
              type: 'string',
            },
          },
          type: {
            type: 'string',
          },
          flows: {
            type: 'array',
            items: {
              type: 'object',
              required: ['locations'],
              properties: {
                locations: {
                  type: 'array',
                  items: {
                    type: 'object',
                    required: ['textRange', 'msg', 'msgFormattings'],
                    properties: {
                      msg: {
                        type: 'string',
                      },
                      textRange: {
                        type: 'object',
                        required: [
                          'startLine',
                          'endLine',
                          'startOffset',
                          'endOffset',
                        ],
                        properties: {
                          endLine: {
                            type: 'number',
                          },
                          endOffset: {
                            type: 'number',
                          },
                          startLine: {
                            type: 'number',
                          },
                          startOffset: {
                            type: 'number',
                          },
                        },
                      },
                      msgFormattings: {
                        type: 'array',
                        items: {
                          type: 'object',
                          required: ['start', 'end', 'type'],
                          properties: {
                            end: {
                              type: 'number',
                            },
                            type: {
                              type: 'string',
                            },
                            start: {
                              type: 'number',
                            },
                          },
                        },
                      },
                    },
                  },
                },
              },
            },
          },
          author: {
            type: 'string',
          },
          effort: {
            type: 'string',
          },
          status: {
            type: 'string',
          },
          actions: {
            type: 'array',
            items: {
              type: 'string',
            },
          },
          impacts: {
            type: 'array',
            items: {
              type: 'object',
              required: ['softwareQuality', 'severity'],
              properties: {
                severity: {
                  type: 'string',
                },
                softwareQuality: {
                  type: 'string',
                },
              },
            },
          },
          message: {
            type: 'string',
          },
          project: {
            type: 'string',
          },
          comments: {
            type: 'array',
            items: {
              type: 'object',
              required: [
                'key',
                'login',
                'htmlText',
                'markdown',
                'updatable',
                'createdAt',
              ],
              properties: {
                key: {
                  type: 'string',
                },
                login: {
                  type: 'string',
                },
                htmlText: {
                  type: 'string',
                },
                markdown: {
                  type: 'string',
                },
                createdAt: {
                  type: 'string',
                },
                updatable: {
                  type: 'boolean',
                },
              },
            },
          },
          severity: {
            type: 'string',
          },
          component: {
            type: 'string',
          },
          textRange: {
            type: 'object',
            required: ['startLine', 'endLine', 'startOffset', 'endOffset'],
            properties: {
              endLine: {
                type: 'number',
              },
              endOffset: {
                type: 'number',
              },
              startLine: {
                type: 'number',
              },
              startOffset: {
                type: 'number',
              },
            },
          },
          updateDate: {
            type: 'string',
          },
          issueStatus: {
            type: 'string',
          },
          transitions: {
            type: 'array',
            items: {
              type: 'string',
            },
          },
          codeVariants: {
            type: 'array',
            items: {
              type: 'string',
            },
          },
          creationDate: {
            type: 'string',
          },
          prioritizedRule: {
            type: 'boolean',
          },
          quickFixAvailable: {
            type: 'boolean',
          },
          cleanCodeAttribute: {
            type: 'string',
          },
          messageFormattings: {
            type: 'array',
            items: {
              type: 'object',
              required: ['start', 'end', 'type'],
              properties: {
                end: {
                  type: 'number',
                },
                type: {
                  type: 'string',
                },
                start: {
                  type: 'number',
                },
              },
            },
          },
          ruleDescriptionContextKey: {
            type: 'string',
          },
          cleanCodeAttributeCategory: {
            type: 'string',
          },
        },
      },
    },
    paging: {
      $ref: '#/components/schemas/Paging',
    },
    components: {
      type: 'array',
      items: {
        type: 'object',
        required: ['key', 'enabled', 'qualifier', 'name', 'longName'],
        properties: {
          key: {
            type: 'string',
          },
          name: {
            type: 'string',
          },
          path: {
            type: 'string',
          },
          enabled: {
            type: 'boolean',
          },
          longName: {
            type: 'string',
          },
          qualifier: {
            type: 'string',
          },
        },
      },
    },
  },
  description: 'Response object from the Issue Search API',
} as const;

export const ProjectSearchResponseSchema = {
  type: 'object',
  required: ['components', 'paging'],
  properties: {
    paging: {
      $ref: '#/components/schemas/Paging',
    },
    components: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/Component',
      },
    },
  },
  description: 'Response type for searching for a project',
} as const;

export const MeasureComponentResponseSchema = {
  type: 'object',
  title: 'Generated schema for Root',
  required: ['component', 'metrics', 'period'],
  properties: {
    period: {
      type: 'object',
      required: ['mode', 'date', 'parameter'],
      properties: {
        date: {
          type: 'string',
        },
        mode: {
          type: 'string',
        },
        parameter: {
          type: 'string',
        },
      },
    },
    metrics: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/Metric',
      },
    },
    component: {
      type: 'object',
      required: ['key', 'name', 'qualifier', 'language', 'path', 'measures'],
      properties: {
        key: {
          type: 'string',
        },
        name: {
          type: 'string',
        },
        path: {
          type: 'string',
        },
        language: {
          type: 'string',
        },
        measures: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/Measure',
          },
        },
        qualifier: {
          type: 'string',
        },
      },
    },
  },
  description: 'Response from the /measures/component endpoint',
} as const;

export const UserTokenDetailsSchema = {
  type: 'object',
  title: 'User Token Details',
  required: ['name', 'createdAt'],
  properties: {
    name: {
      type: 'string',
      description: 'Token name',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Token creation date',
    },
    lastConnectionDate: {
      type: 'string',
      format: 'date-time',
      description: 'Last date the token was used',
    },
    expirationDate: {
      type: 'string',
      format: 'date',
      description: 'Token expiration date',
    },
    type: {
      type: 'string',
      enum: ['USER_TOKEN', 'GLOBAL_ANALYSIS_TOKEN', 'PROJECT_ANALYSIS_TOKEN'],
      description: 'Token type',
    },
    projectKey: {
      type: 'string',
      description: 'Project key for PROJECT_ANALYSIS_TOKEN',
    },
    projectName: {
      type: 'string',
      description: 'Project name for PROJECT_ANALYSIS_TOKEN',
    },
  },
  description: 'A user token',
} as const;

export const UserTokenSearchResponseSchema = {
  type: 'object',
  title: 'User Token Search Response',
  required: ['userTokens'],
  properties: {
    login: {
      type: 'string',
      description: 'User login',
    },
    userTokens: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/UserTokenDetails',
      },
    },
  },
  description: 'Response from the user token search endpoint',
} as const;

export const UserTokenGenerateResponseSchema = {
  type: 'object',
  title: 'User Token Generate Response',
  required: ['name', 'token', 'createdAt'],
  properties: {
    name: {
      type: 'string',
      description: 'Token name',
    },
    token: {
      type: 'string',
      description: 'The generated token value (only returned once)',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Token creation date',
    },
    login: {
      type: 'string',
      description: 'User login',
    },
    type: {
      type: 'string',
      enum: ['USER_TOKEN', 'GLOBAL_ANALYSIS_TOKEN', 'PROJECT_ANALYSIS_TOKEN'],
      description: 'Token type',
    },
    projectKey: {
      type: 'string',
      description: 'Project key for PROJECT_ANALYSIS_TOKEN',
    },
    projectName: {
      type: 'string',
      description: 'Project name for PROJECT_ANALYSIS_TOKEN',
    },
    expirationDate: {
      type: 'string',
      format: 'date',
      description: 'Token expiration date',
    },
  },
  description: 'Response from the user token generate endpoint',
} as const;

export const UserCreateRestRequestWritableSchema = {
  type: 'object',
  properties: {
    email: {
      type: 'string',
      description: 'User email',
      maxLength: 100,
      minLength: 1,
    },
    local: {
      type: 'boolean',
      default: 'true',
      description:
        'Specify if the user should be authenticated from SonarQube server or from an external authentication system. Password should not be set when local is set to false.',
    },
    login: {
      type: 'string',
      description: 'User login',
      maxLength: 100,
      minLength: 2,
    },
    name: {
      type: 'string',
      description: 'User name',
      maxLength: 200,
      minLength: 0,
    },
    password: {
      type: 'string',
      description:
        'User password. Only mandatory when creating local user, otherwise it should not be set',
      writeOnly: true,
    },
    scmAccounts: {
      type: 'array',
      description: 'List of SCM accounts.',
      items: {
        type: 'string',
      },
    },
  },
  required: ['login', 'name'],
} as const;

export const UserRestResponseForAdminsWritableSchema = {
  type: 'object',
  properties: {
    login: {
      type: 'string',
    },
    name: {
      type: 'string',
    },
    email: {
      type: 'string',
    },
    externalLogin: {
      type: 'string',
    },
    externalProvider: {
      type: 'string',
    },
    externalId: {
      type: 'string',
    },
    avatar: {
      type: 'string',
    },
    scmAccounts: {
      type: 'array',
      items: {
        type: 'string',
      },
    },
  },
} as const;

export const EmailConfigurationCreateRestRequestWritableSchema = {
  type: 'object',
  properties: {
    host: {
      type: 'string',
      description: 'URL of your SMTP server',
    },
    port: {
      type: 'string',
      description: 'Port of your SMTP server (usually 25, 587 or 465)',
    },
    securityProtocol: {
      type: 'string',
      description:
        'Security protocol used to connect to your SMTP server (SSLTLS is recommended)',
      enum: ['NONE', 'SSLTLS', 'STARTTLS'],
    },
    fromAddress: {
      type: 'string',
      description: 'Address emails will come from',
    },
    fromName: {
      type: 'string',
      description: 'Name emails will come from (usually "SonarQube")',
    },
    subjectPrefix: {
      type: 'string',
      description:
        'Prefix added to email so they can be easily recognized (usually "[SonarQube]")',
    },
    authMethod: {
      type: 'string',
      description:
        'Authentication method used to connect to the SMTP server. OAuth is only supported for Microsoft Exchange',
      enum: ['BASIC', 'OAUTH'],
    },
    username: {
      type: 'string',
      description:
        'For Basic and OAuth authentication: username used to authenticate to the SMTP server',
    },
    basicPassword: {
      type: 'string',
      description:
        'For basic authentication: password used to authenticate to the SMTP server',
      writeOnly: true,
    },
    oauthAuthenticationHost: {
      type: 'string',
      description:
        'For OAuth authentication: host of the Identity Provider issuing access tokens',
    },
    oauthClientId: {
      type: 'string',
      description:
        'For OAuth authentication: Client ID provided by Microsoft Exchange when registering the application',
      writeOnly: true,
    },
    oauthClientSecret: {
      type: 'string',
      description:
        'For OAuth authentication: Client secret provided by Microsoft Exchange when registering the application',
      writeOnly: true,
    },
    oauthTenant: {
      type: 'string',
      description: 'For OAuth authentication: Microsoft tenant',
    },
  },
  required: [
    'authMethod',
    'fromAddress',
    'fromName',
    'host',
    'port',
    'securityProtocol',
    'subjectPrefix',
    'username',
  ],
} as const;

export const EmailConfigurationResourceWritableSchema = {
  type: 'object',
  properties: {
    host: {
      type: 'string',
      description: 'URL of your SMTP server',
    },
    port: {
      type: 'string',
      description: 'Port of your SMTP server (usually 25, 587 or 465)',
    },
    securityProtocol: {
      type: 'string',
      description:
        'Security protocol used to connect to your SMTP server (SSLTLS is recommended)',
      enum: ['NONE', 'SSLTLS', 'STARTTLS'],
    },
    fromAddress: {
      type: 'string',
      description: 'Address emails will come from',
    },
    fromName: {
      type: 'string',
      description: 'Name emails will come from (usually "SonarQube")',
    },
    subjectPrefix: {
      type: 'string',
      description:
        'Prefix added to email so they can be easily recognized (usually "[SonarQube]")',
    },
    authMethod: {
      type: 'string',
      description:
        'Authentication method used to connect to the SMTP server. OAuth is only supported for Microsoft Exchange',
      enum: ['BASIC', 'OAUTH'],
    },
    username: {
      type: 'string',
      description:
        'For Basic and OAuth authentication: username used to authenticate to the SMTP server',
    },
    isBasicPasswordSet: {
      type: 'boolean',
      description: 'For Basic authentication: has the password field been set?',
    },
    oauthAuthenticationHost: {
      type: 'string',
      description:
        'For OAuth authentication: host of the Identity Provider issuing access tokens',
    },
    isOauthClientIdSet: {
      type: 'boolean',
      description:
        'For OAuth authentication: has the Client ID field been set?',
    },
    isOauthClientSecretSet: {
      type: 'boolean',
      description:
        'For OAuth authentication: has the Client secret field been set?',
    },
    oauthTenant: {
      type: 'string',
      description: 'For OAuth authentication: Microsoft tenant',
    },
  },
} as const;

export const GitlabConfigurationCreateRestRequestWritableSchema = {
  type: 'object',
  properties: {
    enabled: {
      type: 'boolean',
      description: 'Enable Gitlab authentication',
    },
    applicationId: {
      type: 'string',
      description: 'Gitlab Application id',
    },
    url: {
      type: 'string',
      description:
        'Url of Gitlab instance for authentication (for instance https://gitlab.com)',
    },
    secret: {
      type: 'string',
      description: 'Secret of the application',
      writeOnly: true,
    },
    synchronizeGroups: {
      type: 'boolean',
      description: 'Set whether to synchronize groups',
    },
    allowedGroups: {
      type: 'array',
      items: {
        type: 'string',
      },
    },
    provisioningType: {
      type: 'string',
      description: 'Type of synchronization',
      enum: ['JIT', 'AUTO_PROVISIONING'],
    },
    provisioningToken: {
      type: 'string',
      description: 'Gitlab token for provisioning',
      writeOnly: true,
    },
    allowUsersToSignUp: {
      type: 'boolean',
      description: 'Allow user to sign up',
    },
  },
  required: [
    'allowedGroups',
    'applicationId',
    'enabled',
    'provisioningType',
    'secret',
    'synchronizeGroups',
    'url',
  ],
} as const;

export const GitlabConfigurationResourceWritableSchema = {
  type: 'object',
  properties: {
    enabled: {
      type: 'boolean',
    },
    applicationId: {
      type: 'string',
      description: 'Gitlab Application id',
    },
    url: {
      type: 'string',
      description:
        'Url of Gitlab instance for authentication (for instance https://gitlab.com/api/v4)',
    },
    synchronizeGroups: {
      type: 'boolean',
    },
    allowedGroups: {
      type: 'array',
      description: 'Root Gitlab groups allowed to authenticate and provisioned',
      items: {
        type: 'string',
      },
    },
    allowUsersToSignUp: {
      type: 'boolean',
    },
    provisioningType: {
      type: 'string',
      enum: ['JIT', 'AUTO_PROVISIONING'],
    },
  },
} as const;

export const GithubConfigurationCreateRestRequestWritableSchema = {
  type: 'object',
  properties: {
    enabled: {
      type: 'boolean',
      description: 'Enable GitHub authentication',
    },
    clientId: {
      type: 'string',
      description:
        'Client ID provided by GitHub when registering the application.',
      writeOnly: true,
    },
    clientSecret: {
      type: 'string',
      description:
        'Client password provided by GitHub when registering the application.',
      writeOnly: true,
    },
    applicationId: {
      type: 'string',
      description:
        "The App ID is found on your GitHub App's page on GitHub at Settings > Developer Settings > GitHub Apps.",
    },
    privateKey: {
      type: 'string',
      description: `Your GitHub App's private key. You can generate a .pem file from your GitHub App's page under Private keys.
Copy and paste the whole contents of the file here.
`,
      writeOnly: true,
    },
    synchronizeGroups: {
      type: 'boolean',
      description: `Synchronize GitHub team with SonarQube group memberships when users log in to SonarQube.
For each GitHub team they belong to, users will be associated to a group of the same name if it exists in SonarQube.
`,
    },
    apiUrl: {
      type: 'string',
      description:
        'The API url for a GitHub instance. https://api.github.com/ for Github.com, https://github.company.com/api/v3/ when using Github Enterprise',
    },
    webUrl: {
      type: 'string',
      description: `The WEB url for a GitHub instance. https://github.com/ for Github.com, https://github.company.com/ when using GitHub Enterprise.
`,
    },
    allowedOrganizations: {
      type: 'array',
      items: {
        type: 'string',
      },
    },
    provisioningType: {
      type: 'string',
      description: 'Type of synchronization',
      enum: ['JIT', 'AUTO_PROVISIONING'],
    },
    allowUsersToSignUp: {
      type: 'boolean',
      description: 'Allow user to sign up',
    },
    projectVisibility: {
      type: 'boolean',
      description: `Change project visibility based on GitHub repository visibility.
If disabled, every provisioned project will be private in SonarQube and visible only to users with explicit GitHub permissions for the corresponding repository.
Changes take effect at the next synchronization.
`,
    },
    userConsentRequiredAfterUpgrade: {
      type: 'boolean',
      description: 'Admin consent to synchronize permissions from GitHub',
    },
  },
  required: [
    'allowedOrganizations',
    'apiUrl',
    'applicationId',
    'clientId',
    'clientSecret',
    'enabled',
    'privateKey',
    'provisioningType',
    'synchronizeGroups',
    'webUrl',
  ],
} as const;

export const GithubConfigurationResourceWritableSchema = {
  type: 'object',
  properties: {
    enabled: {
      type: 'boolean',
    },
    applicationId: {
      type: 'string',
      description: 'GitHub Application id',
    },
    synchronizeGroups: {
      type: 'boolean',
    },
    apiUrl: {
      type: 'string',
      description:
        'Url of GitHub instance for API connectivity (for instance https://api.github.com)',
    },
    webUrl: {
      type: 'string',
      description:
        'Url of GitHub instance for authentication (for instance https://github.com)',
    },
    allowedOrganizations: {
      type: 'array',
      description:
        'GitHub organizations allowed to authenticate and provisioned',
      items: {
        type: 'string',
      },
    },
    provisioningType: {
      type: 'string',
      enum: ['JIT', 'AUTO_PROVISIONING'],
    },
    allowUsersToSignUp: {
      type: 'boolean',
    },
    projectVisibility: {
      type: 'boolean',
    },
    userConsentRequiredAfterUpgrade: {
      type: 'boolean',
    },
  },
} as const;

export const ParameterWritableSchema = {
  type: 'object',
  properties: {
    key: {
      type: 'string',
    },
    defaultValue: {
      type: 'string',
    },
  },
} as const;

export const RuleDescriptionSectionRestResponseWritableSchema = {
  type: 'object',
} as const;

export const GroupRestResponseWritableSchema = {
  type: 'object',
  properties: {
    name: {
      type: 'string',
    },
    description: {
      type: 'string',
    },
  },
} as const;

export const ModeResourceWritableSchema = {
  type: 'object',
  properties: {
    mode: {
      type: 'string',
      enum: ['MQR', 'STANDARD_EXPERIENCE'],
    },
  },
  required: ['mode'],
} as const;

export const DopSettingsResourceWritableSchema = {
  type: 'object',
  properties: {
    type: {
      type: 'string',
      description:
        'Supported DevOps Platform are: github, gitlab, azure, bitbucketcloud, bitbucket_server',
    },
    key: {
      type: 'string',
    },
    url: {
      type: 'string',
    },
    appId: {
      type: 'string',
    },
  },
} as const;

export const GroupsMembershipSearchRestResponseWritableSchema = {
  type: 'object',
  properties: {
    groupMemberships: {
      type: 'array',
    },
    page: {
      $ref: '#/components/schemas/PageRestResponse',
    },
  },
} as const;
